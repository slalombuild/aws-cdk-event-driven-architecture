"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudExecutable = void 0;
const fs_1 = require("fs");
const cxapi = require("@aws-cdk/cx-api");
const region_info_1 = require("@aws-cdk/region-info");
const semver = require("semver");
const contextproviders = require("../../context-providers");
const logging_1 = require("../../logging");
const cloud_assembly_1 = require("./cloud-assembly");
/**
 * The Cloud Assembly schema version where the framework started to generate analytics itself
 *
 * See https://github.com/aws/aws-cdk/pull/10306
 */
const TEMPLATE_INCLUDES_ANALYTICS_SCHEMA_VERSION = '6.0.0';
/**
 * Represent the Cloud Executable and the synthesis we can do on it
 */
class CloudExecutable {
    constructor(props) {
        this.props = props;
    }
    /**
     * Return whether there is an app command from the configuration
     */
    get hasApp() {
        return !!this.props.configuration.settings.get(['app']);
    }
    /**
     * Synthesize a set of stacks.
     *
     * @param cacheCloudAssembly whether to cache the Cloud Assembly after it has been first synthesized.
     *   This is 'true' by default, and only set to 'false' for 'cdk watch',
     *   which needs to re-synthesize the Assembly each time it detects a change to the project files
     */
    async synthesize(cacheCloudAssembly = true) {
        if (!this._cloudAssembly || !cacheCloudAssembly) {
            this._cloudAssembly = await this.doSynthesize();
        }
        return this._cloudAssembly;
    }
    async doSynthesize() {
        const trackVersions = this.props.configuration.settings.get(['versionReporting']);
        // We may need to run the cloud executable multiple times in order to satisfy all missing context
        // (When the executable runs, it will tell us about context it wants to use
        // but it missing. We'll then look up the context and run the executable again, and
        // again, until it doesn't complain anymore or we've stopped making progress).
        let previouslyMissingKeys;
        while (true) {
            const assembly = await this.props.synthesizer(this.props.sdkProvider, this.props.configuration);
            if (assembly.manifest.missing && assembly.manifest.missing.length > 0) {
                const missingKeys = missingContextKeys(assembly.manifest.missing);
                if (!this.canLookup) {
                    throw new Error('Context lookups have been disabled. '
                        + 'Make sure all necessary context is already in \'cdk.context.json\' by running \'cdk synth\' on a machine with sufficient AWS credentials and committing the result. '
                        + `Missing context keys: '${Array.from(missingKeys).join(', ')}'`);
                }
                let tryLookup = true;
                if (previouslyMissingKeys && setsEqual(missingKeys, previouslyMissingKeys)) {
                    logging_1.debug('Not making progress trying to resolve environmental context. Giving up.');
                    tryLookup = false;
                }
                previouslyMissingKeys = missingKeys;
                if (tryLookup) {
                    logging_1.debug('Some context information is missing. Fetching...');
                    await contextproviders.provideContextValues(assembly.manifest.missing, this.props.configuration.context, this.props.sdkProvider);
                    // Cache the new context to disk
                    await this.props.configuration.saveContext();
                    // Execute again
                    continue;
                }
            }
            if (trackVersions && !semver.gte(assembly.version, TEMPLATE_INCLUDES_ANALYTICS_SCHEMA_VERSION)) {
                // @deprecate(v2): the framework now manages its own analytics. For
                // Cloud Assemblies *older* than when we introduced this feature, have
                // the CLI add it. Otherwise, do nothing.
                await this.addMetadataResource(assembly);
            }
            return new cloud_assembly_1.CloudAssembly(assembly);
        }
    }
    /**
     * Modify the templates in the assembly in-place to add metadata resource declarations
     */
    async addMetadataResource(rootAssembly) {
        if (!rootAssembly.runtime) {
            return;
        }
        const modules = formatModules(rootAssembly.runtime);
        await processAssembly(rootAssembly);
        async function processAssembly(assembly) {
            for (const stack of assembly.stacks) {
                await processStack(stack);
            }
            for (const nested of assembly.nestedAssemblies) {
                await processAssembly(nested.nestedAssembly);
            }
        }
        async function processStack(stack) {
            const resourcePresent = stack.environment.region === cxapi.UNKNOWN_REGION
                || region_info_1.RegionInfo.get(stack.environment.region).cdkMetadataResourceAvailable;
            if (!resourcePresent) {
                return;
            }
            if (!stack.template.Resources) {
                stack.template.Resources = {};
            }
            if (stack.template.Resources.CDKMetadata) {
                // Already added by framework, this is expected.
                return;
            }
            stack.template.Resources.CDKMetadata = {
                Type: 'AWS::CDK::Metadata',
                Properties: {
                    Modules: modules,
                },
            };
            if (stack.environment.region === cxapi.UNKNOWN_REGION) {
                stack.template.Conditions = stack.template.Conditions || {};
                const condName = 'CDKMetadataAvailable';
                if (!stack.template.Conditions[condName]) {
                    stack.template.Conditions[condName] = _makeCdkMetadataAvailableCondition();
                    stack.template.Resources.CDKMetadata.Condition = condName;
                }
                else {
                    logging_1.warning(`The stack ${stack.id} already includes a ${condName} condition`);
                }
            }
            // The template has changed in-memory, but the file on disk remains unchanged so far.
            // The CLI *might* later on deploy the in-memory version (if it's <50kB) or use the
            // on-disk version (if it's >50kB).
            //
            // Be sure to flush the changes we just made back to disk. The on-disk format is always
            // JSON.
            await fs_1.promises.writeFile(stack.templateFullPath, JSON.stringify(stack.template, undefined, 2), { encoding: 'utf-8' });
        }
    }
    get canLookup() {
        return !!(this.props.configuration.settings.get(['lookups']) ?? true);
    }
}
exports.CloudExecutable = CloudExecutable;
/**
 * Return all keys of missing context items
 */
function missingContextKeys(missing) {
    return new Set((missing || []).map(m => m.key));
}
function setsEqual(a, b) {
    if (a.size !== b.size) {
        return false;
    }
    for (const x of a) {
        if (!b.has(x)) {
            return false;
        }
    }
    return true;
}
function _makeCdkMetadataAvailableCondition() {
    return _fnOr(region_info_1.RegionInfo.regions
        .filter(ri => ri.cdkMetadataResourceAvailable)
        .map(ri => ({ 'Fn::Equals': [{ Ref: 'AWS::Region' }, ri.name] })));
}
/**
 * This takes a bunch of operands and crafts an `Fn::Or` for those. Funny thing is `Fn::Or` requires
 * at least 2 operands and at most 10 operands, so we have to... do this.
 */
function _fnOr(operands) {
    if (operands.length === 0) {
        throw new Error('Cannot build `Fn::Or` with zero operands!');
    }
    if (operands.length === 1) {
        return operands[0];
    }
    if (operands.length <= 10) {
        return { 'Fn::Or': operands };
    }
    return _fnOr(_inGroupsOf(operands, 10).map(group => _fnOr(group)));
}
function _inGroupsOf(array, maxGroup) {
    const result = new Array();
    for (let i = 0; i < array.length; i += maxGroup) {
        result.push(array.slice(i, i + maxGroup));
    }
    return result;
}
function formatModules(runtime) {
    const modules = new Array();
    // inject toolkit version to list of modules
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const toolkitVersion = require('../../../package.json').version;
    modules.push(`aws-cdk=${toolkitVersion}`);
    for (const key of Object.keys(runtime.libraries).sort()) {
        modules.push(`${key}=${runtime.libraries[key]}`);
    }
    return modules.join(',');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWQtZXhlY3V0YWJsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNsb3VkLWV4ZWN1dGFibGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMkJBQW9DO0FBQ3BDLHlDQUF5QztBQUN6QyxzREFBa0Q7QUFDbEQsaUNBQWlDO0FBQ2pDLDREQUE0RDtBQUM1RCwyQ0FBK0M7QUFHL0MscURBQWlEO0FBT2pEOzs7O0dBSUc7QUFDSCxNQUFNLDBDQUEwQyxHQUFHLE9BQU8sQ0FBQztBQW1CM0Q7O0dBRUc7QUFDSCxNQUFhLGVBQWU7SUFHMUIsWUFBNkIsS0FBMkI7UUFBM0IsVUFBSyxHQUFMLEtBQUssQ0FBc0I7SUFDeEQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxNQUFNO1FBQ2YsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLEtBQUssQ0FBQyxVQUFVLENBQUMscUJBQThCLElBQUk7UUFDeEQsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtZQUMvQyxJQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1NBQ2pEO1FBQ0QsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQzdCLENBQUM7SUFFTyxLQUFLLENBQUMsWUFBWTtRQUN4QixNQUFNLGFBQWEsR0FBWSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO1FBRTNGLGlHQUFpRztRQUNqRywyRUFBMkU7UUFDM0UsbUZBQW1GO1FBQ25GLDhFQUE4RTtRQUM5RSxJQUFJLHFCQUE4QyxDQUFDO1FBQ25ELE9BQU8sSUFBSSxFQUFFO1lBQ1gsTUFB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QkFBdUIsQ0FBQyxDQUFDLE9BQU8sQ0FBQztJQUNoRSxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsY0FBYyxFQUFFLENBQUMsQ0FBQztJQUUxQyxLQUFLLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ3ZELE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDbEQ7SUFDRCxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDM0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHByb21pc2VzIGFzIGZzIH0gZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IFJlZ2lvbkluZm8gfSBmcm9tICdAYXdzLWNkay9yZWdpb24taW5mbyc7XG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCAqIGFzIGNvbnRleHRwcm92aWRlcnMgZnJvbSAnLi4vLi4vY29udGV4dC1wcm92aWRlcnMnO1xuaW1wb3J0IHsgZGVidWcsIHdhcm5pbmcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IENvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi8uLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyBTZGtQcm92aWRlciB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB7IENsb3VkQXNzZW1ibHkgfSBmcm9tICcuL2Nsb3VkLWFzc2VtYmx5JztcblxuLyoqXG4gKiBAcmV0dXJucyBvdXRwdXQgZGlyZWN0b3J5XG4gKi9cbnR5cGUgU3ludGhlc2l6ZXIgPSAoYXdzOiBTZGtQcm92aWRlciwgY29uZmlnOiBDb25maWd1cmF0aW9uKSA9PiBQcm9taXNlPGN4YXBpLkNsb3VkQXNzZW1ibHk+O1xuXG4vKipcbiAqIFRoZSBDbG91ZCBBc3NlbWJseSBzY2hlbWEgdmVyc2lvbiB3aGVyZSB0aGUgZnJhbWV3b3JrIHN0YXJ0ZWQgdG8gZ2VuZXJhdGUgYW5hbHl0aWNzIGl0c2VsZlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvcHVsbC8xMDMwNlxuICovXG5jb25zdCBURU1QTEFURV9JTkNMVURFU19BTkFMWVRJQ1NfU0NIRU1BX1ZFUlNJT04gPSAnNi4wLjAnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENsb3VkRXhlY3V0YWJsZVByb3BzIHtcbiAgLyoqXG4gICAqIEFwcGxpY2F0aW9uIGNvbmZpZ3VyYXRpb24gKHNldHRpbmdzIGFuZCBjb250ZXh0KVxuICAgKi9cbiAgY29uZmlndXJhdGlvbjogQ29uZmlndXJhdGlvbjtcblxuICAvKipcbiAgICogQVdTIG9iamVjdCAodXNlZCBieSBzeW50aGVzaXplciBhbmQgY29udGV4dHByb3ZpZGVyKVxuICAgKi9cbiAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyO1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBpbnZva2VkIHRvIHN5bnRoZXNpemUgdGhlIGFjdHVhbCBzdGFja3NcbiAgICovXG4gIHN5bnRoZXNpemVyOiBTeW50aGVzaXplcjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgdGhlIENsb3VkIEV4ZWN1dGFibGUgYW5kIHRoZSBzeW50aGVzaXMgd2UgY2FuIGRvIG9uIGl0XG4gKi9cbmV4cG9ydCBjbGFzcyBDbG91ZEV4ZWN1dGFibGUge1xuICBwcml2YXRlIF9jbG91ZEFzc2VtYmx5PzogQ2xvdWRBc3NlbWJseTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBDbG91ZEV4ZWN1dGFibGVQcm9wcykge1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZXJlIGlzIGFuIGFwcCBjb21tYW5kIGZyb20gdGhlIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIHB1YmxpYyBnZXQgaGFzQXBwKCkge1xuICAgIHJldHVybiAhIXRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWydhcHAnXSk7XG4gIH1cblxuICAvKipcbiAgICogU3ludGhlc2l6ZSBhIHNldCBvZiBzdGFja3MuXG4gICAqXG4gICAqIEBwYXJhbSBjYWNoZUNsb3VkQXNzZW1ibHkgd2hldGhlciB0byBjYWNoZSB0aGUgQ2xvdWQgQXNzZW1ibHkgYWZ0ZXIgaXQgaGFzIGJlZW4gZmlyc3Qgc3ludGhlc2l6ZWQuXG4gICAqICAgVGhpcyBpcyAndHJ1ZScgYnkgZGVmYXVsdCwgYW5kIG9ubHkgc2V0IHRvICdmYWxzZScgZm9yICdjZGsgd2F0Y2gnLFxuICAgKiAgIHdoaWNoIG5lZWRzIHRvIHJlLXN5bnRoZXNpemUgdGhlIEFzc2VtYmx5IGVhY2ggdGltZSBpdCBkZXRlY3RzIGEgY2hhbmdlIHRvIHRoZSBwcm9qZWN0IGZpbGVzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3ludGhlc2l6ZShjYWNoZUNsb3VkQXNzZW1ibHk6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTxDbG91ZEFzc2VtYmx5PiB7XG4gICAgaWYgKCF0aGlzLl9jbG91ZEFzc2VtYmx5IHx8ICFjYWNoZUNsb3VkQXNzZW1ibHkpIHtcbiAgICAgIHRoaXMuX2Nsb3VkQXNzZW1ibHkgPSBhd2FpdCB0aGlzLmRvU3ludGhlc2l6ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xvdWRBc3NlbWJseTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZG9TeW50aGVzaXplKCk6IFByb21pc2U8Q2xvdWRBc3NlbWJseT4ge1xuICAgIGNvbnN0IHRyYWNrVmVyc2lvbnM6IGJvb2xlYW4gPSB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uc2V0dGluZ3MuZ2V0KFsndmVyc2lvblJlcG9ydGluZyddKTtcblxuICAgIC8vIFdlIG1heSBuZWVkIHRvIHJ1biB0aGUgY2xvdWQgZXhlY3V0YWJsZSBtdWx0aXBsZSB0aW1lcyBpbiBvcmRlciB0byBzYXRpc2Z5IGFsbCBtaXNzaW5nIGNvbnRleHRcbiAgICAvLyAoV2hlbiB0aGUgZXhlY3V0YWJsZSBydW5zLCBpdCB3aWxsIHRlbGwgdXMgYWJvdXQgY29udGV4dCBpdCB3YW50cyB0byB1c2VcbiAgICAvLyBidXQgaXQgbWlzc2luZy4gV2UnbGwgdGhlbiBsb29rIHVwIHRoZSBjb250ZXh0IGFuZCBydW4gdGhlIGV4ZWN1dGFibGUgYWdhaW4sIGFuZFxuICAgIC8vIGFnYWluLCB1bnRpbCBpdCBkb2Vzbid0IGNvbXBsYWluIGFueW1vcmUgb3Igd2UndmUgc3RvcHBlZCBtYWtpbmcgcHJvZ3Jlc3MpLlxuICAgIGxldCBwcmV2aW91c2x5TWlzc2luZ0tleXM6IFNldDxzdHJpbmc+IHwgdW5kZWZpbmVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IHRoaXMucHJvcHMuc3ludGhlc2l6ZXIodGhpcy5wcm9wcy5zZGtQcm92aWRlciwgdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uKTtcblxuICAgICAgaWYgKGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcgJiYgYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdLZXlzID0gbWlzc2luZ0NvbnRleHRLZXlzKGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcpO1xuXG4gICAgICAgIGlmICghdGhpcy5jYW5Mb29rdXApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ29udGV4dCBsb29rdXBzIGhhdmUgYmVlbiBkaXNhYmxlZC4gJ1xuICAgICAgICAgICAgKyAnTWFrZSBzdXJlIGFsbCBuZWNlc3NhcnkgY29udGV4dCBpcyBhbHJlYWR5IGluIFxcJ2Nkay5jb250ZXh0Lmpzb25cXCcgYnkgcnVubmluZyBcXCdjZGsgc3ludGhcXCcgb24gYSBtYWNoaW5lIHdpdGggc3VmZmljaWVudCBBV1MgY3JlZGVudGlhbHMgYW5kIGNvbW1pdHRpbmcgdGhlIHJlc3VsdC4gJ1xuICAgICAgICAgICAgKyBgTWlzc2luZyBjb250ZXh0IGtleXM6ICcke0FycmF5LmZyb20obWlzc2luZ0tleXMpLmpvaW4oJywgJyl9J2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRyeUxvb2t1cCA9IHRydWU7XG4gICAgICAgIGlmIChwcmV2aW91c2x5TWlzc2luZ0tleXMgJiYgc2V0c0VxdWFsKG1pc3NpbmdLZXlzLCBwcmV2aW91c2x5TWlzc2luZ0tleXMpKSB7XG4gICAgICAgICAgZGVidWcoJ05vdCBtYWtpbmcgcHJvZ3Jlc3MgdHJ5aW5nIHRvIHJlc29sdmUgZW52aXJvbm1lbnRhbCBjb250ZXh0LiBHaXZpbmcgdXAuJyk7XG4gICAgICAgICAgdHJ5TG9va3VwID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c2x5TWlzc2luZ0tleXMgPSBtaXNzaW5nS2V5cztcblxuICAgICAgICBpZiAodHJ5TG9va3VwKSB7XG4gICAgICAgICAgZGVidWcoJ1NvbWUgY29udGV4dCBpbmZvcm1hdGlvbiBpcyBtaXNzaW5nLiBGZXRjaGluZy4uLicpO1xuXG4gICAgICAgICAgYXdhaXQgY29udGV4dHByb3ZpZGVycy5wcm92aWRlQ29udGV4dFZhbHVlcyhcbiAgICAgICAgICAgIGFzc2VtYmx5Lm1hbmlmZXN0Lm1pc3NpbmcsXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uY29udGV4dCxcbiAgICAgICAgICAgIHRoaXMucHJvcHMuc2RrUHJvdmlkZXIpO1xuXG4gICAgICAgICAgLy8gQ2FjaGUgdGhlIG5ldyBjb250ZXh0IHRvIGRpc2tcbiAgICAgICAgICBhd2FpdCB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uc2F2ZUNvbnRleHQoKTtcblxuICAgICAgICAgIC8vIEV4ZWN1dGUgYWdhaW5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2tWZXJzaW9ucyAmJiAhc2VtdmVyLmd0ZShhc3NlbWJseS52ZXJzaW9uLCBURU1QTEFURV9JTkNMVURFU19BTkFMWVRJQ1NfU0NIRU1BX1ZFUlNJT04pKSB7XG4gICAgICAgIC8vIEBkZXByZWNhdGUodjIpOiB0aGUgZnJhbWV3b3JrIG5vdyBtYW5hZ2VzIGl0cyBvd24gYW5hbHl0aWNzLiBGb3JcbiAgICAgICAgLy8gQ2xvdWQgQXNzZW1ibGllcyAqb2xkZXIqIHRoYW4gd2hlbiB3ZSBpbnRyb2R1Y2VkIHRoaXMgZmVhdHVyZSwgaGF2ZVxuICAgICAgICAvLyB0aGUgQ0xJIGFkZCBpdC4gT3RoZXJ3aXNlLCBkbyBub3RoaW5nLlxuICAgICAgICBhd2FpdCB0aGlzLmFkZE1ldGFkYXRhUmVzb3VyY2UoYXNzZW1ibHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IENsb3VkQXNzZW1ibHkoYXNzZW1ibHkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIHRlbXBsYXRlcyBpbiB0aGUgYXNzZW1ibHkgaW4tcGxhY2UgdG8gYWRkIG1ldGFkYXRhIHJlc291cmNlIGRlY2xhcmF0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBhZGRNZXRhZGF0YVJlc291cmNlKHJvb3RBc3NlbWJseTogY3hhcGkuQ2xvdWRBc3NlbWJseSkge1xuICAgIGlmICghcm9vdEFzc2VtYmx5LnJ1bnRpbWUpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBtb2R1bGVzID0gZm9ybWF0TW9kdWxlcyhyb290QXNzZW1ibHkucnVudGltZSk7XG4gICAgYXdhaXQgcHJvY2Vzc0Fzc2VtYmx5KHJvb3RBc3NlbWJseSk7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQXNzZW1ibHkoYXNzZW1ibHk6IGN4YXBpLkNsb3VkQXNzZW1ibHkpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RhY2sgb2YgYXNzZW1ibHkuc3RhY2tzKSB7XG4gICAgICAgIGF3YWl0IHByb2Nlc3NTdGFjayhzdGFjayk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG5lc3RlZCBvZiBhc3NlbWJseS5uZXN0ZWRBc3NlbWJsaWVzKSB7XG4gICAgICAgIGF3YWl0IHByb2Nlc3NBc3NlbWJseShuZXN0ZWQubmVzdGVkQXNzZW1ibHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTdGFjayhzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KSB7XG4gICAgICBjb25zdCByZXNvdXJjZVByZXNlbnQgPSBzdGFjay5lbnZpcm9ubWVudC5yZWdpb24gPT09IGN4YXBpLlVOS05PV05fUkVHSU9OXG4gICAgICAgIHx8IFJlZ2lvbkluZm8uZ2V0KHN0YWNrLmVudmlyb25tZW50LnJlZ2lvbikuY2RrTWV0YWRhdGFSZXNvdXJjZUF2YWlsYWJsZTtcbiAgICAgIGlmICghcmVzb3VyY2VQcmVzZW50KSB7IHJldHVybjsgfVxuXG4gICAgICBpZiAoIXN0YWNrLnRlbXBsYXRlLlJlc291cmNlcykge1xuICAgICAgICBzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMuQ0RLTWV0YWRhdGEpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhZGRlZCBieSBmcmFtZXdvcmssIHRoaXMgaXMgZXhwZWN0ZWQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzLkNES01ldGFkYXRhID0ge1xuICAgICAgICBUeXBlOiAnQVdTOjpDREs6Ok1ldGFkYXRhJyxcbiAgICAgICAgUHJvcGVydGllczoge1xuICAgICAgICAgIE1vZHVsZXM6IG1vZHVsZXMsXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBpZiAoc3RhY2suZW52aXJvbm1lbnQucmVnaW9uID09PSBjeGFwaS5VTktOT1dOX1JFR0lPTikge1xuICAgICAgICBzdGFjay50ZW1wbGF0ZS5Db25kaXRpb25zID0gc3RhY2sudGVtcGxhdGUuQ29uZGl0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgY29uZE5hbWUgPSAnQ0RLTWV0YWRhdGFBdmFpbGFibGUnO1xuICAgICAgICBpZiAoIXN0YWNrLnRlbXBsYXRlLkNvbmRpdGlvbnNbY29uZE5hbWVdKSB7XG4gICAgICAgICAgc3RhY2sudGVtcGxhdGUuQ29uZGl0aW9uc1tjb25kTmFtZV0gPSBfbWFrZUNka01ldGFkYXRhQXZhaWxhYmxlQ29uZGl0aW9uKCk7XG4gICAgICAgICAgc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzLkNES01ldGFkYXRhLkNvbmRpdGlvbiA9IGNvbmROYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5pbmcoYFRoZSBzdGFjayAke3N0YWNrLmlkfSBhbHJlYWR5IGluY2x1ZGVzIGEgJHtjb25kTmFtZX0gY29uZGl0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHRlbXBsYXRlIGhhcyBjaGFuZ2VkIGluLW1lbW9yeSwgYnV0IHRoZSBmaWxlIG9uIGRpc2sgcmVtYWlucyB1bmNoYW5nZWQgc28gZmFyLlxuICAgICAgLy8gVGhlIENMSSAqbWlnaHQqIGxhdGVyIG9uIGRlcGxveSB0aGUgaW4tbWVtb3J5IHZlcnNpb24gKGlmIGl0J3MgPDUwa0IpIG9yIHVzZSB0aGVcbiAgICAgIC8vIG9uLWRpc2sgdmVyc2lvbiAoaWYgaXQncyA+NTBrQikuXG4gICAgICAvL1xuICAgICAgLy8gQmUgc3VyZSB0byBmbHVzaCB0aGUgY2hhbmdlcyB3ZSBqdXN0IG1hZGUgYmFjayB0byBkaXNrLiBUaGUgb24tZGlzayBmb3JtYXQgaXMgYWx3YXlzXG4gICAgICAvLyBKU09OLlxuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHN0YWNrLnRlbXBsYXRlRnVsbFBhdGgsIEpTT04uc3RyaW5naWZ5KHN0YWNrLnRlbXBsYXRlLCB1bmRlZmluZWQsIDIpLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGNhbkxvb2t1cCgpIHtcbiAgICByZXR1cm4gISEodGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ2xvb2t1cHMnXSkgPz8gdHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gYWxsIGtleXMgb2YgbWlzc2luZyBjb250ZXh0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIG1pc3NpbmdDb250ZXh0S2V5cyhtaXNzaW5nPzogY3hhcGkuTWlzc2luZ0NvbnRleHRbXSk6IFNldDxzdHJpbmc+IHtcbiAgcmV0dXJuIG5ldyBTZXQoKG1pc3NpbmcgfHwgW10pLm1hcChtID0+IG0ua2V5KSk7XG59XG5cbmZ1bmN0aW9uIHNldHNFcXVhbDxBPihhOiBTZXQ8QT4sIGI6IFNldDxBPikge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGZvciAoY29uc3QgeCBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyh4KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX21ha2VDZGtNZXRhZGF0YUF2YWlsYWJsZUNvbmRpdGlvbigpIHtcbiAgcmV0dXJuIF9mbk9yKFJlZ2lvbkluZm8ucmVnaW9uc1xuICAgIC5maWx0ZXIocmkgPT4gcmkuY2RrTWV0YWRhdGFSZXNvdXJjZUF2YWlsYWJsZSlcbiAgICAubWFwKHJpID0+ICh7ICdGbjo6RXF1YWxzJzogW3sgUmVmOiAnQVdTOjpSZWdpb24nIH0sIHJpLm5hbWVdIH0pKSk7XG59XG5cbi8qKlxuICogVGhpcyB0YWtlcyBhIGJ1bmNoIG9mIG9wZXJhbmRzIGFuZCBjcmFmdHMgYW4gYEZuOjpPcmAgZm9yIHRob3NlLiBGdW5ueSB0aGluZyBpcyBgRm46Ok9yYCByZXF1aXJlc1xuICogYXQgbGVhc3QgMiBvcGVyYW5kcyBhbmQgYXQgbW9zdCAxMCBvcGVyYW5kcywgc28gd2UgaGF2ZSB0by4uLiBkbyB0aGlzLlxuICovXG5mdW5jdGlvbiBfZm5PcihvcGVyYW5kczogYW55W10pOiBhbnkge1xuICBpZiAob3BlcmFuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYnVpbGQgYEZuOjpPcmAgd2l0aCB6ZXJvIG9wZXJhbmRzIScpO1xuICB9XG4gIGlmIChvcGVyYW5kcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gb3BlcmFuZHNbMF07XG4gIH1cbiAgaWYgKG9wZXJhbmRzLmxlbmd0aCA8PSAxMCkge1xuICAgIHJldHVybiB7ICdGbjo6T3InOiBvcGVyYW5kcyB9O1xuICB9XG4gIHJldHVybiBfZm5PcihfaW5Hcm91cHNPZihvcGVyYW5kcywgMTApLm1hcChncm91cCA9PiBfZm5Pcihncm91cCkpKTtcbn1cblxuZnVuY3Rpb24gX2luR3JvdXBzT2Y8VD4oYXJyYXk6IFRbXSwgbWF4R3JvdXA6IG51bWJlcik6IFRbXVtdIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PFRbXT4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gbWF4R3JvdXApIHtcbiAgICByZXN1bHQucHVzaChhcnJheS5zbGljZShpLCBpICsgbWF4R3JvdXApKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNb2R1bGVzKHJ1bnRpbWU6IGN4YXBpLlJ1bnRpbWVJbmZvKTogc3RyaW5nIHtcbiAgY29uc3QgbW9kdWxlcyA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgLy8gaW5qZWN0IHRvb2xraXQgdmVyc2lvbiB0byBsaXN0IG9mIG1vZHVsZXNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgdG9vbGtpdFZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICBtb2R1bGVzLnB1c2goYGF3cy1jZGs9JHt0b29sa2l0VmVyc2lvbn1gKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhydW50aW1lLmxpYnJhcmllcykuc29ydCgpKSB7XG4gICAgbW9kdWxlcy5wdXNoKGAke2tleX09JHtydW50aW1lLmxpYnJhcmllc1trZXldfWApO1xuICB9XG4gIHJldHVybiBtb2R1bGVzLmpvaW4oJywnKTtcbn1cbiJdfQ==