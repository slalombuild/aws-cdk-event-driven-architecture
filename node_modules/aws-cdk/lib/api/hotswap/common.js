"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lowerCaseFirstCharacter = exports.transformObjectKeys = exports.HotswappableChangeCandidate = exports.ChangeHotswapImpact = exports.ICON = void 0;
exports.ICON = 'âœ¨';
/**
 * An enum that represents the result of detection whether a given change can be hotswapped.
 */
var ChangeHotswapImpact;
(function (ChangeHotswapImpact) {
    /**
     * This result means that the given change cannot be hotswapped,
     * and requires a full deployment.
     */
    ChangeHotswapImpact["REQUIRES_FULL_DEPLOYMENT"] = "requires-full-deployment";
    /**
     * This result means that the given change can be safely be ignored when determining
     * whether the given Stack can be hotswapped or not
     * (for example, it's a change to the CDKMetadata resource).
     */
    ChangeHotswapImpact["IRRELEVANT"] = "irrelevant";
})(ChangeHotswapImpact = exports.ChangeHotswapImpact || (exports.ChangeHotswapImpact = {}));
/**
 * Represents a change that can be hotswapped.
 */
class HotswappableChangeCandidate {
    constructor(newValue, propertyUpdates) {
        this.newValue = newValue;
        this.propertyUpdates = propertyUpdates;
    }
}
exports.HotswappableChangeCandidate = HotswappableChangeCandidate;
/**
 * This function transforms all keys (recursively) in the provided `val` object.
 *
 * @param val The object whose keys need to be transformed.
 * @param transform The function that will be applied to each key.
 * @param exclude The keys that will not be transformed and copied to output directly
 * @returns A new object with the same values as `val`, but with all keys transformed according to `transform`.
 */
function transformObjectKeys(val, transform, exclude = {}) {
    if (val == null || typeof val !== 'object') {
        return val;
    }
    if (Array.isArray(val)) {
        // For arrays we just pass parent's exclude object directly
        // since it makes no sense to specify different exclude options for each array element
        return val.map((input) => transformObjectKeys(input, transform, exclude));
    }
    const ret = {};
    for (const [k, v] of Object.entries(val)) {
        const childExclude = exclude[k];
        if (childExclude === true) {
            // we don't transform this object if the key is specified in exclude
            ret[transform(k)] = v;
        }
        else {
            ret[transform(k)] = transformObjectKeys(v, transform, childExclude);
        }
    }
    return ret;
}
exports.transformObjectKeys = transformObjectKeys;
/**
 * This function lower cases the first character of the string provided.
 */
function lowerCaseFirstCharacter(str) {
    return str.length > 0 ? `${str[0].toLowerCase()}${str.slice(1)}` : str;
}
exports.lowerCaseFirstCharacter = lowerCaseFirstCharacter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tbW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUdhLFFBQUEsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQW9CeEI7O0dBRUc7QUFDSCxJQUFZLG1CQWFYO0FBYkQsV0FBWSxtQkFBbUI7SUFDN0I7OztPQUdHO0lBQ0gsNEVBQXFELENBQUE7SUFFckQ7Ozs7T0FJRztJQUNILGdEQUF5QixDQUFBO0FBQzNCLENBQUMsRUFiVyxtQkFBbUIsR0FBbkIsMkJBQW1CLEtBQW5CLDJCQUFtQixRQWE5QjtBQUlEOztHQUVHO0FBQ0gsTUFBYSwyQkFBMkI7SUFXdEMsWUFBbUIsUUFBMkIsRUFBRSxlQUFvRTtRQUNsSCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztJQUN6QyxDQUFDO0NBQ0Y7QUFmRCxrRUFlQztBQUlEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQixtQkFBbUIsQ0FBQyxHQUFRLEVBQUUsU0FBa0MsRUFBRSxVQUFtQixFQUFFO0lBQ3JHLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7UUFDMUMsT0FBTyxHQUFHLENBQUM7S0FDWjtJQUNELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUN0QiwyREFBMkQ7UUFDM0Qsc0ZBQXNGO1FBQ3RGLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQVUsRUFBRSxFQUFFLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO0tBQ2hGO0lBQ0QsTUFBTSxHQUFHLEdBQTBCLEVBQUUsQ0FBQztJQUN0QyxLQUFLLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUN4QyxNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEMsSUFBSSxZQUFZLEtBQUssSUFBSSxFQUFFO1lBQ3pCLG9FQUFvRTtZQUNwRSxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3ZCO2FBQU07WUFDTCxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsbUJBQW1CLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxZQUFZLENBQUMsQ0FBQztTQUNyRTtLQUNGO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBcEJELGtEQW9CQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsdUJBQXVCLENBQUMsR0FBVztJQUNqRCxPQUFPLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUN6RSxDQUFDO0FBRkQsMERBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZm5fZGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5cbmV4cG9ydCBjb25zdCBJQ09OID0gJ+KcqCc7XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyBhIGNoYW5nZSB0aGF0IGNhbiBiZSBkZXBsb3llZCBpbiBhIHNob3J0LWNpcmN1aXQgbWFubmVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhvdHN3YXBPcGVyYXRpb24ge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHNlcnZpY2UgYmVpbmcgaG90c3dhcHBlZC5cbiAgICogVXNlZCB0byBzZXQgYSBjdXN0b20gVXNlci1BZ2VudCBmb3IgU0RLIGNhbGxzLlxuICAgKi9cbiAgcmVhZG9ubHkgc2VydmljZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgb2YgdGhlIHJlc291cmNlcyBiZWluZyBob3Rzd2FwcGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VOYW1lczogc3RyaW5nW107XG5cbiAgYXBwbHkoc2RrOiBJU0RLKTogUHJvbWlzZTxhbnk+O1xufVxuXG4vKipcbiAqIEFuIGVudW0gdGhhdCByZXByZXNlbnRzIHRoZSByZXN1bHQgb2YgZGV0ZWN0aW9uIHdoZXRoZXIgYSBnaXZlbiBjaGFuZ2UgY2FuIGJlIGhvdHN3YXBwZWQuXG4gKi9cbmV4cG9ydCBlbnVtIENoYW5nZUhvdHN3YXBJbXBhY3Qge1xuICAvKipcbiAgICogVGhpcyByZXN1bHQgbWVhbnMgdGhhdCB0aGUgZ2l2ZW4gY2hhbmdlIGNhbm5vdCBiZSBob3Rzd2FwcGVkLFxuICAgKiBhbmQgcmVxdWlyZXMgYSBmdWxsIGRlcGxveW1lbnQuXG4gICAqL1xuICBSRVFVSVJFU19GVUxMX0RFUExPWU1FTlQgPSAncmVxdWlyZXMtZnVsbC1kZXBsb3ltZW50JyxcblxuICAvKipcbiAgICogVGhpcyByZXN1bHQgbWVhbnMgdGhhdCB0aGUgZ2l2ZW4gY2hhbmdlIGNhbiBiZSBzYWZlbHkgYmUgaWdub3JlZCB3aGVuIGRldGVybWluaW5nXG4gICAqIHdoZXRoZXIgdGhlIGdpdmVuIFN0YWNrIGNhbiBiZSBob3Rzd2FwcGVkIG9yIG5vdFxuICAgKiAoZm9yIGV4YW1wbGUsIGl0J3MgYSBjaGFuZ2UgdG8gdGhlIENES01ldGFkYXRhIHJlc291cmNlKS5cbiAgICovXG4gIElSUkVMRVZBTlQgPSAnaXJyZWxldmFudCcsXG59XG5cbmV4cG9ydCB0eXBlIENoYW5nZUhvdHN3YXBSZXN1bHQgPSBIb3Rzd2FwT3BlcmF0aW9uIHwgQ2hhbmdlSG90c3dhcEltcGFjdDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhbmdlIHRoYXQgY2FuIGJlIGhvdHN3YXBwZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUge1xuICAvKipcbiAgICogVGhlIHZhbHVlIHRoZSByZXNvdXJjZSBpcyBiZWluZyB1cGRhdGVkIHRvLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IG5ld1ZhbHVlOiBjZm5fZGlmZi5SZXNvdXJjZTtcblxuICAvKipcbiAgICogVGhlIGNoYW5nZXMgbWFkZSB0byB0aGUgcmVzb3VyY2UgcHJvcGVydGllcy5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwcm9wZXJ0eVVwZGF0ZXM6IHsgW2tleTogc3RyaW5nXTogY2ZuX2RpZmYuUHJvcGVydHlEaWZmZXJlbmNlPGFueT4gfTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IobmV3VmFsdWU6IGNmbl9kaWZmLlJlc291cmNlLCBwcm9wZXJ0eVVwZGF0ZXM6IHsgW2tleTogc3RyaW5nXTogY2ZuX2RpZmYuUHJvcGVydHlEaWZmZXJlbmNlPGFueT4gfSkge1xuICAgIHRoaXMubmV3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB0aGlzLnByb3BlcnR5VXBkYXRlcyA9IHByb3BlcnR5VXBkYXRlcztcbiAgfVxufVxuXG50eXBlIEV4Y2x1ZGUgPSB7IFtrZXk6IHN0cmluZ106IEV4Y2x1ZGUgfCB0cnVlIH1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyYW5zZm9ybXMgYWxsIGtleXMgKHJlY3Vyc2l2ZWx5KSBpbiB0aGUgcHJvdmlkZWQgYHZhbGAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWwgVGhlIG9iamVjdCB3aG9zZSBrZXlzIG5lZWQgdG8gYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0gdHJhbnNmb3JtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBlYWNoIGtleS5cbiAqIEBwYXJhbSBleGNsdWRlIFRoZSBrZXlzIHRoYXQgd2lsbCBub3QgYmUgdHJhbnNmb3JtZWQgYW5kIGNvcGllZCB0byBvdXRwdXQgZGlyZWN0bHlcbiAqIEByZXR1cm5zIEEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyBgdmFsYCwgYnV0IHdpdGggYWxsIGtleXMgdHJhbnNmb3JtZWQgYWNjb3JkaW5nIHRvIGB0cmFuc2Zvcm1gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtT2JqZWN0S2V5cyh2YWw6IGFueSwgdHJhbnNmb3JtOiAoc3RyOiBzdHJpbmcpID0+IHN0cmluZywgZXhjbHVkZTogRXhjbHVkZSA9IHt9KTogYW55IHtcbiAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgLy8gRm9yIGFycmF5cyB3ZSBqdXN0IHBhc3MgcGFyZW50J3MgZXhjbHVkZSBvYmplY3QgZGlyZWN0bHlcbiAgICAvLyBzaW5jZSBpdCBtYWtlcyBubyBzZW5zZSB0byBzcGVjaWZ5IGRpZmZlcmVudCBleGNsdWRlIG9wdGlvbnMgZm9yIGVhY2ggYXJyYXkgZWxlbWVudFxuICAgIHJldHVybiB2YWwubWFwKChpbnB1dDogYW55KSA9PiB0cmFuc2Zvcm1PYmplY3RLZXlzKGlucHV0LCB0cmFuc2Zvcm0sIGV4Y2x1ZGUpKTtcbiAgfVxuICBjb25zdCByZXQ6IHsgW2s6IHN0cmluZ106IGFueTsgfSA9IHt9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWwpKSB7XG4gICAgY29uc3QgY2hpbGRFeGNsdWRlID0gZXhjbHVkZVtrXTtcbiAgICBpZiAoY2hpbGRFeGNsdWRlID09PSB0cnVlKSB7XG4gICAgICAvLyB3ZSBkb24ndCB0cmFuc2Zvcm0gdGhpcyBvYmplY3QgaWYgdGhlIGtleSBpcyBzcGVjaWZpZWQgaW4gZXhjbHVkZVxuICAgICAgcmV0W3RyYW5zZm9ybShrKV0gPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRbdHJhbnNmb3JtKGspXSA9IHRyYW5zZm9ybU9iamVjdEtleXModiwgdHJhbnNmb3JtLCBjaGlsZEV4Y2x1ZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gbG93ZXIgY2FzZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nIHByb3ZpZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG93ZXJDYXNlRmlyc3RDaGFyYWN0ZXIoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gc3RyLmxlbmd0aCA+IDAgPyBgJHtzdHJbMF0udG9Mb3dlckNhc2UoKX0ke3N0ci5zbGljZSgxKX1gIDogc3RyO1xufVxuIl19