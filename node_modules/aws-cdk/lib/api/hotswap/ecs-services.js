"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableEcsServiceChange = void 0;
const AWS = require("aws-sdk");
const common_1 = require("./common");
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate) {
    // the only resource change we should allow is an ECS TaskDefinition
    if (change.newValue.Type !== 'AWS::ECS::TaskDefinition') {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    for (const updatedPropName in change.propertyUpdates) {
        // We only allow a change in the ContainerDefinitions of the TaskDefinition for now -
        // it contains the image and environment variables, so seems like a safe bet for now.
        // We might revisit this decision in the future though!
        if (updatedPropName !== 'ContainerDefinitions') {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        const containerDefinitionsDifference = (change.propertyUpdates)[updatedPropName];
        if (containerDefinitionsDifference.newValue === undefined) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
    }
    // at this point, we know the TaskDefinition can be hotswapped
    // find all ECS Services that reference the TaskDefinition that changed
    const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
    const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter(r => r.Type === 'AWS::ECS::Service');
    const ecsServicesReferencingTaskDef = new Array();
    for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
        const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
        if (serviceArn) {
            ecsServicesReferencingTaskDef.push({ serviceArn });
        }
    }
    if (ecsServicesReferencingTaskDef.length === 0 ||
        resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
        // if there are either no resources referencing the TaskDefinition,
        // or something besides an ECS Service is referencing it,
        // hotswap is not possible
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    const taskDefinitionResource = change.newValue.Properties;
    // first, let's get the name of the family
    const familyNameOrArn = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, taskDefinitionResource?.Family);
    if (!familyNameOrArn) {
        // if the Family property has not bee provided, and we can't find it in the current Stack,
        // this means hotswapping is not possible
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    // the physical name of the Task Definition in CloudFormation includes its current revision number at the end,
    // remove it if needed
    const familyNameOrArnParts = familyNameOrArn.split(':');
    const family = familyNameOrArnParts.length > 1
        // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
        // so, take the 6th element, at index 5, and split it on '/'
        ? familyNameOrArnParts[5].split('/')[1]
        // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
        : familyNameOrArn;
    // then, let's evaluate the body of the remainder of the TaskDef (without the Family property)
    const evaluatedTaskDef = {
        ...await evaluateCfnTemplate.evaluateCfnExpression({
            ...(taskDefinitionResource ?? {}),
            Family: undefined,
        }),
        Family: family,
    };
    return new EcsServiceHotswapOperation(evaluatedTaskDef, ecsServicesReferencingTaskDef);
}
exports.isHotswappableEcsServiceChange = isHotswappableEcsServiceChange;
class EcsServiceHotswapOperation {
    constructor(taskDefinitionResource, servicesReferencingTaskDef) {
        this.taskDefinitionResource = taskDefinitionResource;
        this.servicesReferencingTaskDef = servicesReferencingTaskDef;
        this.service = 'ecs-service';
        this.resourceNames = [];
        this.resourceNames = servicesReferencingTaskDef.map(ecsService => `ECS Service '${ecsService.serviceArn.split('/')[2]}'`);
    }
    async apply(sdk) {
        // Step 1 - update the changed TaskDefinition, creating a new TaskDefinition Revision
        // we need to lowercase the evaluated TaskDef from CloudFormation,
        // as the AWS SDK uses lowercase property names for these
        const lowercasedTaskDef = common_1.transformObjectKeys(this.taskDefinitionResource, common_1.lowerCaseFirstCharacter, {
            // All the properties that take arbitrary string as keys i.e. { "string" : "string" }
            // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RegisterTaskDefinition.html#API_RegisterTaskDefinition_RequestSyntax
            ContainerDefinitions: {
                DockerLabels: true,
                FirelensConfiguration: {
                    Options: true,
                },
                LogConfiguration: {
                    Options: true,
                },
            },
            Volumes: {
                DockerVolumeConfiguration: {
                    DriverOpts: true,
                    Labels: true,
                },
            },
        });
        const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef).promise();
        const taskDefRevArn = registerTaskDefResponse.taskDefinition?.taskDefinitionArn;
        // Step 2 - update the services using that TaskDefinition to point to the new TaskDefinition Revision
        const servicePerClusterUpdates = {};
        for (const ecsService of this.servicesReferencingTaskDef) {
            const clusterName = ecsService.serviceArn.split('/')[1];
            const existingClusterPromises = servicePerClusterUpdates[clusterName];
            let clusterPromises;
            if (existingClusterPromises) {
                clusterPromises = existingClusterPromises;
            }
            else {
                clusterPromises = [];
                servicePerClusterUpdates[clusterName] = clusterPromises;
            }
            clusterPromises.push({
                promise: sdk.ecs().updateService({
                    service: ecsService.serviceArn,
                    taskDefinition: taskDefRevArn,
                    cluster: clusterName,
                    forceNewDeployment: true,
                    deploymentConfiguration: {
                        minimumHealthyPercent: 0,
                    },
                }).promise(),
                ecsService: ecsService,
            });
        }
        await Promise.all(Object.values(servicePerClusterUpdates)
            .map(clusterUpdates => {
            return Promise.all(clusterUpdates.map(serviceUpdate => serviceUpdate.promise));
        }));
        // Step 3 - wait for the service deployments triggered in Step 2 to finish
        // configure a custom Waiter
        sdk.ecs().api.waiters.deploymentToFinish = {
            name: 'DeploymentToFinish',
            operation: 'describeServices',
            delay: 10,
            maxAttempts: 60,
            acceptors: [
                {
                    matcher: 'pathAny',
                    argument: 'failures[].reason',
                    expected: 'MISSING',
                    state: 'failure',
                },
                {
                    matcher: 'pathAny',
                    argument: 'services[].status',
                    expected: 'DRAINING',
                    state: 'failure',
                },
                {
                    matcher: 'pathAny',
                    argument: 'services[].status',
                    expected: 'INACTIVE',
                    state: 'failure',
                },
                {
                    matcher: 'path',
                    argument: "length(services[].deployments[? status == 'PRIMARY' && runningCount < desiredCount][]) == `0`",
                    expected: true,
                    state: 'success',
                },
            ],
        };
        // create a custom Waiter that uses the deploymentToFinish configuration added above
        const deploymentWaiter = new AWS.ResourceWaiter(sdk.ecs(), 'deploymentToFinish');
        // wait for all of the waiters to finish
        return Promise.all(Object.entries(servicePerClusterUpdates).map(([clusterName, serviceUpdates]) => {
            return deploymentWaiter.wait({
                cluster: clusterName,
                services: serviceUpdates.map(serviceUpdate => serviceUpdate.ecsService.serviceArn),
            }).promise();
        }));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNzLXNlcnZpY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWNzLXNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUcvQixxQ0FBaUs7QUFFMUosS0FBSyxVQUFVLDhCQUE4QixDQUNsRCxTQUFpQixFQUFFLE1BQW1DLEVBQUUsbUJBQW1EO0lBRTNHLG9FQUFvRTtJQUNwRSxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLDBCQUEwQixFQUFFO1FBQ3ZELE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7S0FDckQ7SUFFRCxLQUFLLE1BQU0sZUFBZSxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUU7UUFDcEQscUZBQXFGO1FBQ3JGLHFGQUFxRjtRQUNyRix1REFBdUQ7UUFDdkQsSUFBSSxlQUFlLEtBQUssc0JBQXNCLEVBQUU7WUFDOUMsT0FBTyw0QkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQztTQUNyRDtRQUNELE1BQU0sOEJBQThCLEdBQUcsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDakYsSUFBSSw4QkFBOEIsQ0FBQyxRQUFRLEtBQUssU0FBUyxFQUFFO1lBQ3pELE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7U0FDckQ7S0FDRjtJQUNELDhEQUE4RDtJQUU5RCx1RUFBdUU7SUFDdkUsTUFBTSwyQkFBMkIsR0FBRyxtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwRixNQUFNLHFDQUFxQyxHQUFHLDJCQUEyQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssbUJBQW1CLENBQUMsQ0FBQztJQUN0SCxNQUFNLDZCQUE2QixHQUFHLElBQUksS0FBSyxFQUFjLENBQUM7SUFDOUQsS0FBSyxNQUFNLGtCQUFrQixJQUFJLHFDQUFxQyxFQUFFO1FBQ3RFLE1BQU0sVUFB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LE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsY0FBYyxDQUFDLEVBQUUsRUFBRTtZQUNoRyxPQUFPLGdCQUFnQixDQUFDLElBQUksQ0FBQztnQkFDM0IsT0FBTyxFQUFFLFdBQVc7Z0JBQ3BCLFFBQVEsRUFBRSxjQUFjLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7YUFDbkYsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2YsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNOLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuLi9ldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZSc7XG5pbXBvcnQgeyBDaGFuZ2VIb3Rzd2FwSW1wYWN0LCBDaGFuZ2VIb3Rzd2FwUmVzdWx0LCBIb3Rzd2FwT3BlcmF0aW9uLCBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGxvd2VyQ2FzZUZpcnN0Q2hhcmFjdGVyLCB0cmFuc2Zvcm1PYmplY3RLZXlzIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNIb3Rzd2FwcGFibGVFY3NTZXJ2aWNlQ2hhbmdlKFxuICBsb2dpY2FsSWQ6IHN0cmluZywgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbik6IFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD4ge1xuICAvLyB0aGUgb25seSByZXNvdXJjZSBjaGFuZ2Ugd2Ugc2hvdWxkIGFsbG93IGlzIGFuIEVDUyBUYXNrRGVmaW5pdGlvblxuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgIT09ICdBV1M6OkVDUzo6VGFza0RlZmluaXRpb24nKSB7XG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICB9XG5cbiAgZm9yIChjb25zdCB1cGRhdGVkUHJvcE5hbWUgaW4gY2hhbmdlLnByb3BlcnR5VXBkYXRlcykge1xuICAgIC8vIFdlIG9ubHkgYWxsb3cgYSBjaGFuZ2UgaW4gdGhlIENvbnRhaW5lckRlZmluaXRpb25zIG9mIHRoZSBUYXNrRGVmaW5pdGlvbiBmb3Igbm93IC1cbiAgICAvLyBpdCBjb250YWlucyB0aGUgaW1hZ2UgYW5kIGVudmlyb25tZW50IHZhcmlhYmxlcywgc28gc2VlbXMgbGlrZSBhIHNhZmUgYmV0IGZvciBub3cuXG4gICAgLy8gV2UgbWlnaHQgcmV2aXNpdCB0aGlzIGRlY2lzaW9uIGluIHRoZSBmdXR1cmUgdGhvdWdoIVxuICAgIGlmICh1cGRhdGVkUHJvcE5hbWUgIT09ICdDb250YWluZXJEZWZpbml0aW9ucycpIHtcbiAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyRGVmaW5pdGlvbnNEaWZmZXJlbmNlID0gKGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMpW3VwZGF0ZWRQcm9wTmFtZV07XG4gICAgaWYgKGNvbnRhaW5lckRlZmluaXRpb25zRGlmZmVyZW5jZS5uZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgfVxuICB9XG4gIC8vIGF0IHRoaXMgcG9pbnQsIHdlIGtub3cgdGhlIFRhc2tEZWZpbml0aW9uIGNhbiBiZSBob3Rzd2FwcGVkXG5cbiAgLy8gZmluZCBhbGwgRUNTIFNlcnZpY2VzIHRoYXQgcmVmZXJlbmNlIHRoZSBUYXNrRGVmaW5pdGlvbiB0aGF0IGNoYW5nZWRcbiAgY29uc3QgcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmID0gZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUmVmZXJlbmNlc1RvKGxvZ2ljYWxJZCk7XG4gIGNvbnN0IGVjc1NlcnZpY2VSZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYuZmlsdGVyKHIgPT4gci5UeXBlID09PSAnQVdTOjpFQ1M6OlNlcnZpY2UnKTtcbiAgY29uc3QgZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSBuZXcgQXJyYXk8RWNzU2VydmljZT4oKTtcbiAgZm9yIChjb25zdCBlY3NTZXJ2aWNlUmVzb3VyY2Ugb2YgZWNzU2VydmljZVJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZikge1xuICAgIGNvbnN0IHNlcnZpY2VBcm4gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRQaHlzaWNhbE5hbWVGb3IoZWNzU2VydmljZVJlc291cmNlLkxvZ2ljYWxJZCk7XG4gICAgaWYgKHNlcnZpY2VBcm4pIHtcbiAgICAgIGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLnB1c2goeyBzZXJ2aWNlQXJuIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoID09PSAwIHx8XG4gICAgICByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoID4gZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoKSB7XG4gICAgLy8gaWYgdGhlcmUgYXJlIGVpdGhlciBubyByZXNvdXJjZXMgcmVmZXJlbmNpbmcgdGhlIFRhc2tEZWZpbml0aW9uLFxuICAgIC8vIG9yIHNvbWV0aGluZyBiZXNpZGVzIGFuIEVDUyBTZXJ2aWNlIGlzIHJlZmVyZW5jaW5nIGl0LFxuICAgIC8vIGhvdHN3YXAgaXMgbm90IHBvc3NpYmxlXG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICB9XG5cbiAgY29uc3QgdGFza0RlZmluaXRpb25SZXNvdXJjZSA9IGNoYW5nZS5uZXdWYWx1ZS5Qcm9wZXJ0aWVzO1xuICAvLyBmaXJzdCwgbGV0J3MgZ2V0IHRoZSBuYW1lIG9mIHRoZSBmYW1pbHlcbiAgY29uc3QgZmFtaWx5TmFtZU9yQXJuID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5lc3RhYmxpc2hSZXNvdXJjZVBoeXNpY2FsTmFtZShsb2dpY2FsSWQsIHRhc2tEZWZpbml0aW9uUmVzb3VyY2U/LkZhbWlseSk7XG4gIGlmICghZmFtaWx5TmFtZU9yQXJuKSB7XG4gICAgLy8gaWYgdGhlIEZhbWlseSBwcm9wZXJ0eSBoYXMgbm90IGJlZSBwcm92aWRlZCwgYW5kIHdlIGNhbid0IGZpbmQgaXQgaW4gdGhlIGN1cnJlbnQgU3RhY2ssXG4gICAgLy8gdGhpcyBtZWFucyBob3Rzd2FwcGluZyBpcyBub3QgcG9zc2libGVcbiAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gIH1cbiAgLy8gdGhlIHBoeXNpY2FsIG5hbWUgb2YgdGhlIFRhc2sgRGVmaW5pdGlvbiBpbiBDbG91ZEZvcm1hdGlvbiBpbmNsdWRlcyBpdHMgY3VycmVudCByZXZpc2lvbiBudW1iZXIgYXQgdGhlIGVuZCxcbiAgLy8gcmVtb3ZlIGl0IGlmIG5lZWRlZFxuICBjb25zdCBmYW1pbHlOYW1lT3JBcm5QYXJ0cyA9IGZhbWlseU5hbWVPckFybi5zcGxpdCgnOicpO1xuICBjb25zdCBmYW1pbHkgPSBmYW1pbHlOYW1lT3JBcm5QYXJ0cy5sZW5ndGggPiAxXG4gICAgLy8gZmFtaWx5TmFtZU9yQXJuIGlzIGFjdHVhbGx5IGFuIEFSTiwgb2YgdGhlIGZvcm1hdCAnYXJuOmF3czplY3M6cmVnaW9uOmFjY291bnQ6dGFzay1kZWZpbml0aW9uLzxmYW1pbHktbmFtZT46PHJldmlzaW9uLW5yPidcbiAgICAvLyBzbywgdGFrZSB0aGUgNnRoIGVsZW1lbnQsIGF0IGluZGV4IDUsIGFuZCBzcGxpdCBpdCBvbiAnLydcbiAgICA/IGZhbWlseU5hbWVPckFyblBhcnRzWzVdLnNwbGl0KCcvJylbMV1cbiAgICAvLyBvdGhlcndpc2UsIGZhbWlseU5hbWVPckFybiBpcyBqdXN0IHRoZSBzaW1wbGUgbmFtZSBldmFsdWF0ZWQgZnJvbSB0aGUgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGVcbiAgICA6IGZhbWlseU5hbWVPckFybjtcbiAgLy8gdGhlbiwgbGV0J3MgZXZhbHVhdGUgdGhlIGJvZHkgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGUgVGFza0RlZiAod2l0aG91dCB0aGUgRmFtaWx5IHByb3BlcnR5KVxuICBjb25zdCBldmFsdWF0ZWRUYXNrRGVmID0ge1xuICAgIC4uLmF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHtcbiAgICAgIC4uLih0YXNrRGVmaW5pdGlvblJlc291cmNlID8/IHt9KSxcbiAgICAgIEZhbWlseTogdW5kZWZpbmVkLFxuICAgIH0pLFxuICAgIEZhbWlseTogZmFtaWx5LFxuICB9O1xuICByZXR1cm4gbmV3IEVjc1NlcnZpY2VIb3Rzd2FwT3BlcmF0aW9uKGV2YWx1YXRlZFRhc2tEZWYsIGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmKTtcbn1cblxuaW50ZXJmYWNlIEVjc1NlcnZpY2Uge1xuICByZWFkb25seSBzZXJ2aWNlQXJuOiBzdHJpbmc7XG59XG5cbmNsYXNzIEVjc1NlcnZpY2VIb3Rzd2FwT3BlcmF0aW9uIGltcGxlbWVudHMgSG90c3dhcE9wZXJhdGlvbiB7XG4gIHB1YmxpYyByZWFkb25seSBzZXJ2aWNlID0gJ2Vjcy1zZXJ2aWNlJztcbiAgcHVibGljIHJlYWRvbmx5IHJlc291cmNlTmFtZXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSB0YXNrRGVmaW5pdGlvblJlc291cmNlOiBhbnksXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZjogRWNzU2VydmljZVtdLFxuICApIHtcbiAgICB0aGlzLnJlc291cmNlTmFtZXMgPSBzZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5tYXAoZWNzU2VydmljZSA9PlxuICAgICAgYEVDUyBTZXJ2aWNlICcke2Vjc1NlcnZpY2Uuc2VydmljZUFybi5zcGxpdCgnLycpWzJdfSdgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBhcHBseShzZGs6IElTREspOiBQcm9taXNlPGFueT4ge1xuICAgIC8vIFN0ZXAgMSAtIHVwZGF0ZSB0aGUgY2hhbmdlZCBUYXNrRGVmaW5pdGlvbiwgY3JlYXRpbmcgYSBuZXcgVGFza0RlZmluaXRpb24gUmV2aXNpb25cbiAgICAvLyB3ZSBuZWVkIHRvIGxvd2VyY2FzZSB0aGUgZXZhbHVhdGVkIFRhc2tEZWYgZnJvbSBDbG91ZEZvcm1hdGlvbixcbiAgICAvLyBhcyB0aGUgQVdTIFNESyB1c2VzIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyBmb3IgdGhlc2VcbiAgICBjb25zdCBsb3dlcmNhc2VkVGFza0RlZiA9IHRyYW5zZm9ybU9iamVjdEtleXModGhpcy50YXNrRGVmaW5pdGlvblJlc291cmNlLCBsb3dlckNhc2VGaXJzdENoYXJhY3Rlciwge1xuICAgICAgLy8gQWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgdGFrZSBhcmJpdHJhcnkgc3RyaW5nIGFzIGtleXMgaS5lLiB7IFwic3RyaW5nXCIgOiBcInN0cmluZ1wiIH1cbiAgICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25FQ1MvbGF0ZXN0L0FQSVJlZmVyZW5jZS9BUElfUmVnaXN0ZXJUYXNrRGVmaW5pdGlvbi5odG1sI0FQSV9SZWdpc3RlclRhc2tEZWZpbml0aW9uX1JlcXVlc3RTeW50YXhcbiAgICAgIENvbnRhaW5lckRlZmluaXRpb25zOiB7XG4gICAgICAgIERvY2tlckxhYmVsczogdHJ1ZSxcbiAgICAgICAgRmlyZWxlbnNDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgT3B0aW9uczogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgTG9nQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgIE9wdGlvbnM6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgVm9sdW1lczoge1xuICAgICAgICBEb2NrZXJWb2x1bWVDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgRHJpdmVyT3B0czogdHJ1ZSxcbiAgICAgICAgICBMYWJlbHM6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IHJlZ2lzdGVyVGFza0RlZlJlc3BvbnNlID0gYXdhaXQgc2RrLmVjcygpLnJlZ2lzdGVyVGFza0RlZmluaXRpb24obG93ZXJjYXNlZFRhc2tEZWYpLnByb21pc2UoKTtcbiAgICBjb25zdCB0YXNrRGVmUmV2QXJuID0gcmVnaXN0ZXJUYXNrRGVmUmVzcG9uc2UudGFza0RlZmluaXRpb24/LnRhc2tEZWZpbml0aW9uQXJuO1xuXG4gICAgLy8gU3RlcCAyIC0gdXBkYXRlIHRoZSBzZXJ2aWNlcyB1c2luZyB0aGF0IFRhc2tEZWZpbml0aW9uIHRvIHBvaW50IHRvIHRoZSBuZXcgVGFza0RlZmluaXRpb24gUmV2aXNpb25cbiAgICBjb25zdCBzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXM6IHsgW2NsdXN0ZXI6IHN0cmluZ106IEFycmF5PHsgcHJvbWlzZTogUHJvbWlzZTxhbnk+LCBlY3NTZXJ2aWNlOiBFY3NTZXJ2aWNlIH0+IH0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGVjc1NlcnZpY2Ugb2YgdGhpcy5zZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZikge1xuICAgICAgY29uc3QgY2x1c3Rlck5hbWUgPSBlY3NTZXJ2aWNlLnNlcnZpY2VBcm4uc3BsaXQoJy8nKVsxXTtcblxuICAgICAgY29uc3QgZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXMgPSBzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXNbY2x1c3Rlck5hbWVdO1xuICAgICAgbGV0IGNsdXN0ZXJQcm9taXNlczogQXJyYXk8eyBwcm9taXNlOiBQcm9taXNlPGFueT4sIGVjc1NlcnZpY2U6IEVjc1NlcnZpY2UgfT47XG4gICAgICBpZiAoZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXMpIHtcbiAgICAgICAgY2x1c3RlclByb21pc2VzID0gZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbHVzdGVyUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzW2NsdXN0ZXJOYW1lXSA9IGNsdXN0ZXJQcm9taXNlcztcbiAgICAgIH1cblxuICAgICAgY2x1c3RlclByb21pc2VzLnB1c2goe1xuICAgICAgICBwcm9taXNlOiBzZGsuZWNzKCkudXBkYXRlU2VydmljZSh7XG4gICAgICAgICAgc2VydmljZTogZWNzU2VydmljZS5zZXJ2aWNlQXJuLFxuICAgICAgICAgIHRhc2tEZWZpbml0aW9uOiB0YXNrRGVmUmV2QXJuLFxuICAgICAgICAgIGNsdXN0ZXI6IGNsdXN0ZXJOYW1lLFxuICAgICAgICAgIGZvcmNlTmV3RGVwbG95bWVudDogdHJ1ZSxcbiAgICAgICAgICBkZXBsb3ltZW50Q29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgbWluaW11bUhlYWx0aHlQZXJjZW50OiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLnByb21pc2UoKSxcbiAgICAgICAgZWNzU2VydmljZTogZWNzU2VydmljZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlcylcbiAgICAgIC5tYXAoY2x1c3RlclVwZGF0ZXMgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2x1c3RlclVwZGF0ZXMubWFwKHNlcnZpY2VVcGRhdGUgPT4gc2VydmljZVVwZGF0ZS5wcm9taXNlKSk7XG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgLy8gU3RlcCAzIC0gd2FpdCBmb3IgdGhlIHNlcnZpY2UgZGVwbG95bWVudHMgdHJpZ2dlcmVkIGluIFN0ZXAgMiB0byBmaW5pc2hcbiAgICAvLyBjb25maWd1cmUgYSBjdXN0b20gV2FpdGVyXG4gICAgKHNkay5lY3MoKSBhcyBhbnkpLmFwaS53YWl0ZXJzLmRlcGxveW1lbnRUb0ZpbmlzaCA9IHtcbiAgICAgIG5hbWU6ICdEZXBsb3ltZW50VG9GaW5pc2gnLFxuICAgICAgb3BlcmF0aW9uOiAnZGVzY3JpYmVTZXJ2aWNlcycsXG4gICAgICBkZWxheTogMTAsXG4gICAgICBtYXhBdHRlbXB0czogNjAsXG4gICAgICBhY2NlcHRvcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXI6ICdwYXRoQW55JyxcbiAgICAgICAgICBhcmd1bWVudDogJ2ZhaWx1cmVzW10ucmVhc29uJyxcbiAgICAgICAgICBleHBlY3RlZDogJ01JU1NJTkcnLFxuICAgICAgICAgIHN0YXRlOiAnZmFpbHVyZScsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVyOiAncGF0aEFueScsXG4gICAgICAgICAgYXJndW1lbnQ6ICdzZXJ2aWNlc1tdLnN0YXR1cycsXG4gICAgICAgICAgZXhwZWN0ZWQ6ICdEUkFJTklORycsXG4gICAgICAgICAgc3RhdGU6ICdmYWlsdXJlJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXI6ICdwYXRoQW55JyxcbiAgICAgICAgICBhcmd1bWVudDogJ3NlcnZpY2VzW10uc3RhdHVzJyxcbiAgICAgICAgICBleHBlY3RlZDogJ0lOQUNUSVZFJyxcbiAgICAgICAgICBzdGF0ZTogJ2ZhaWx1cmUnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcjogJ3BhdGgnLFxuICAgICAgICAgIGFyZ3VtZW50OiBcImxlbmd0aChzZXJ2aWNlc1tdLmRlcGxveW1lbnRzWz8gc3RhdHVzID09ICdQUklNQVJZJyAmJiBydW5uaW5nQ291bnQgPCBkZXNpcmVkQ291bnRdW10pID09IGAwYFwiLFxuICAgICAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgICAgIHN0YXRlOiAnc3VjY2VzcycsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gICAgLy8gY3JlYXRlIGEgY3VzdG9tIFdhaXRlciB0aGF0IHVzZXMgdGhlIGRlcGxveW1lbnRUb0ZpbmlzaCBjb25maWd1cmF0aW9uIGFkZGVkIGFib3ZlXG4gICAgY29uc3QgZGVwbG95bWVudFdhaXRlciA9IG5ldyAoQVdTIGFzIGFueSkuUmVzb3VyY2VXYWl0ZXIoc2RrLmVjcygpLCAnZGVwbG95bWVudFRvRmluaXNoJyk7XG4gICAgLy8gd2FpdCBmb3IgYWxsIG9mIHRoZSB3YWl0ZXJzIHRvIGZpbmlzaFxuICAgIHJldHVybiBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXMpLm1hcCgoW2NsdXN0ZXJOYW1lLCBzZXJ2aWNlVXBkYXRlc10pID0+IHtcbiAgICAgIHJldHVybiBkZXBsb3ltZW50V2FpdGVyLndhaXQoe1xuICAgICAgICBjbHVzdGVyOiBjbHVzdGVyTmFtZSxcbiAgICAgICAgc2VydmljZXM6IHNlcnZpY2VVcGRhdGVzLm1hcChzZXJ2aWNlVXBkYXRlID0+IHNlcnZpY2VVcGRhdGUuZWNzU2VydmljZS5zZXJ2aWNlQXJuKSxcbiAgICAgIH0pLnByb21pc2UoKTtcbiAgICB9KSk7XG4gIH1cbn1cbiJdfQ==