"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterValues = exports.TemplateParameters = exports.stabilizeStack = exports.waitForStackDeploy = exports.waitForStackDelete = exports.changeSetHasNoChanges = exports.waitForChangeSet = exports.CloudFormationStack = void 0;
const cx_api_1 = require("@aws-cdk/cx-api");
const logging_1 = require("../../logging");
const serialize_1 = require("../../serialize");
const stack_status_1 = require("./cloudformation/stack-status");
/**
 * Represents an (existing) Stack in CloudFormation
 *
 * Bundle and cache some information that we need during deployment (so we don't have to make
 * repeated calls to CloudFormation).
 */
class CloudFormationStack {
    constructor(cfn, stackName, stack, retrieveProcessedTemplate = false) {
        this.cfn = cfn;
        this.stackName = stackName;
        this.stack = stack;
        this.retrieveProcessedTemplate = retrieveProcessedTemplate;
    }
    static async lookup(cfn, stackName, retrieveProcessedTemplate = false) {
        try {
            const response = await cfn.describeStacks({ StackName: stackName }).promise();
            return new CloudFormationStack(cfn, stackName, response.Stacks && response.Stacks[0], retrieveProcessedTemplate);
        }
        catch (e) {
            if (e.code === 'ValidationError' && e.message === `Stack with id ${stackName} does not exist`) {
                return new CloudFormationStack(cfn, stackName, undefined);
            }
            throw e;
        }
    }
    /**
     * Return a copy of the given stack that does not exist
     *
     * It's a little silly that it needs arguments to do that, but there we go.
     */
    static doesNotExist(cfn, stackName) {
        return new CloudFormationStack(cfn, stackName);
    }
    /**
     * From static information (for testing)
     */
    static fromStaticInformation(cfn, stackName, stack) {
        return new CloudFormationStack(cfn, stackName, stack);
    }
    /**
     * Retrieve the stack's deployed template
     *
     * Cached, so will only be retrieved once. Will return an empty
     * structure if the stack does not exist.
     */
    async template() {
        if (!this.exists) {
            return {};
        }
        if (this._template === undefined) {
            const response = await this.cfn.getTemplate({
                StackName: this.stackName,
                TemplateStage: this.retrieveProcessedTemplate ? 'Processed' : 'Original',
            }).promise();
            this._template = (response.TemplateBody && serialize_1.deserializeStructure(response.TemplateBody)) || {};
        }
        return this._template;
    }
    /**
     * Whether the stack exists
     */
    get exists() {
        return this.stack !== undefined;
    }
    /**
     * The stack's ID
     *
     * Throws if the stack doesn't exist.
     */
    get stackId() {
        this.assertExists();
        return this.stack.StackId;
    }
    /**
     * The stack's current outputs
     *
     * Empty object if the stack doesn't exist
     */
    get outputs() {
        if (!this.exists) {
            return {};
        }
        const result = {};
        (this.stack.Outputs || []).forEach(output => {
            result[output.OutputKey] = output.OutputValue;
        });
        return result;
    }
    /**
     * The stack's status
     *
     * Special status NOT_FOUND if the stack does not exist.
     */
    get stackStatus() {
        if (!this.exists) {
            return new stack_status_1.StackStatus('NOT_FOUND', 'Stack not found during lookup');
        }
        return stack_status_1.StackStatus.fromStackDescription(this.stack);
    }
    /**
     * The stack's current tags
     *
     * Empty list of the stack does not exist
     */
    get tags() {
        return this.stack?.Tags || [];
    }
    /**
     * Return the names of all current parameters to the stack
     *
     * Empty list if the stack does not exist.
     */
    get parameterNames() {
        return Object.keys(this.parameters);
    }
    /**
     * Return the names and values of all current parameters to the stack
     *
     * Empty object if the stack does not exist.
     */
    get parameters() {
        if (!this.exists) {
            return {};
        }
        const ret = {};
        for (const param of this.stack.Parameters ?? []) {
            ret[param.ParameterKey] = param.ParameterValue;
        }
        return ret;
    }
    /**
     * Return the termination protection of the stack
     */
    get terminationProtection() {
        return this.stack?.EnableTerminationProtection;
    }
    assertExists() {
        if (!this.exists) {
            throw new Error(`No stack named '${this.stackName}'`);
        }
    }
}
exports.CloudFormationStack = CloudFormationStack;
/**
 * Describe a changeset in CloudFormation, regardless of its current state.
 *
 * @param cfn           a CloudFormation client
 * @param stackName     the name of the Stack the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 * @param fetchAll      if true, fetches all pages of the change set description.
 *
 * @returns       CloudFormation information about the ChangeSet
 */
async function describeChangeSet(cfn, stackName, changeSetName, { fetchAll }) {
    const response = await cfn.describeChangeSet({ StackName: stackName, ChangeSetName: changeSetName }).promise();
    // If fetchAll is true, traverse all pages from the change set description.
    while (fetchAll && response.NextToken != null) {
        const nextPage = await cfn.describeChangeSet({
            StackName: stackName,
            ChangeSetName: response.ChangeSetId ?? changeSetName,
            NextToken: response.NextToken,
        }).promise();
        // Consolidate the changes
        if (nextPage.Changes != null) {
            response.Changes = response.Changes != null
                ? response.Changes.concat(nextPage.Changes)
                : nextPage.Changes;
        }
        // Forward the new NextToken
        response.NextToken = nextPage.NextToken;
    }
    return response;
}
/**
 * Waits for a function to return non-+undefined+ before returning.
 *
 * @param valueProvider a function that will return a value that is not +undefined+ once the wait should be over
 * @param timeout     the time to wait between two calls to +valueProvider+
 *
 * @returns       the value that was returned by +valueProvider+
 */
async function waitFor(valueProvider, timeout = 5000) {
    while (true) {
        const result = await valueProvider();
        if (result === null) {
            return undefined;
        }
        else if (result !== undefined) {
            return result;
        }
        await new Promise(cb => setTimeout(cb, timeout));
    }
}
/**
 * Waits for a ChangeSet to be available for triggering a StackUpdate.
 *
 * Will return a changeset that is either ready to be executed or has no changes.
 * Will throw in other cases.
 *
 * @param cfn           a CloudFormation client
 * @param stackName     the name of the Stack that the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 * @param fetchAll      if true, fetches all pages of the ChangeSet before returning.
 *
 * @returns       the CloudFormation description of the ChangeSet
 */
// eslint-disable-next-line max-len
async function waitForChangeSet(cfn, stackName, changeSetName, { fetchAll }) {
    logging_1.debug('Waiting for changeset %s on stack %s to finish creating...', changeSetName, stackName);
    const ret = await waitFor(async () => {
        const description = await describeChangeSet(cfn, stackName, changeSetName, { fetchAll });
        // The following doesn't use a switch because tsc will not allow fall-through, UNLESS it is allows
        // EVERYWHERE that uses this library directly or indirectly, which is undesirable.
        if (description.Status === 'CREATE_PENDING' || description.Status === 'CREATE_IN_PROGRESS') {
            logging_1.debug('Changeset %s on stack %s is still creating', changeSetName, stackName);
            return undefined;
        }
        if (description.Status === 'CREATE_COMPLETE' || changeSetHasNoChanges(description)) {
            return description;
        }
        // eslint-disable-next-line max-len
        throw new Error(`Failed to create ChangeSet ${changeSetName} on ${stackName}: ${description.Status || 'NO_STATUS'}, ${description.StatusReason || 'no reason provided'}`);
    });
    if (!ret) {
        throw new Error('Change set took too long to be created; aborting');
    }
    return ret;
}
exports.waitForChangeSet = waitForChangeSet;
/**
 * Return true if the given change set has no changes
 *
 * This must be determined from the status, not the 'Changes' array on the
 * object; the latter can be empty because no resources were changed, but if
 * there are changes to Outputs, the change set can still be executed.
 */
function changeSetHasNoChanges(description) {
    const noChangeErrorPrefixes = [
        // Error message for a regular template
        'The submitted information didn\'t contain changes.',
        // Error message when a Transform is involved (see #10650)
        'No updates are to be performed.',
    ];
    return description.Status === 'FAILED'
        && noChangeErrorPrefixes.some(p => (description.StatusReason ?? '').startsWith(p));
}
exports.changeSetHasNoChanges = changeSetHasNoChanges;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after a delete operation is issued.
 *
 * Fails if the stack is in a FAILED state. Will not fail if the stack was
 * already deleted.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after a delete
 *
 * @returns     the CloudFormation description of the stabilized stack after the delete attempt
 */
async function waitForStackDelete(cfn, stackName) {
    const stack = await stabilizeStack(cfn, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isFailure) {
        throw new Error(`The stack named ${stackName} is in a failed state. You may need to delete it from the AWS console : ${status}`);
    }
    else if (status.isDeleted) {
        return undefined;
    }
    return stack;
}
exports.waitForStackDelete = waitForStackDelete;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after an update/create operation is issued.
 *
 * Fails if the stack is in a FAILED state, ROLLBACK state, or DELETED state.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after an update
 *
 * @returns     the CloudFormation description of the stabilized stack after the update attempt
 */
async function waitForStackDeploy(cfn, stackName) {
    const stack = await stabilizeStack(cfn, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isCreationFailure) {
        throw new Error(`The stack named ${stackName} failed creation, it may need to be manually deleted from the AWS console: ${status}`);
    }
    else if (!status.isDeploySuccess) {
        throw new Error(`The stack named ${stackName} failed to deploy: ${status}`);
    }
    return stack;
}
exports.waitForStackDeploy = waitForStackDeploy;
/**
 * Wait for a stack to become stable (no longer _IN_PROGRESS), returning it
 */
async function stabilizeStack(cfn, stackName) {
    logging_1.debug('Waiting for stack %s to finish creating or updating...', stackName);
    return waitFor(async () => {
        const stack = await CloudFormationStack.lookup(cfn, stackName);
        if (!stack.exists) {
            logging_1.debug('Stack %s does not exist', stackName);
            return null;
        }
        const status = stack.stackStatus;
        if (status.isInProgress) {
            logging_1.debug('Stack %s has an ongoing operation in progress and is not stable (%s)', stackName, status);
            return undefined;
        }
        return stack;
    });
}
exports.stabilizeStack = stabilizeStack;
/**
 * The set of (formal) parameters that have been declared in a template
 */
class TemplateParameters {
    constructor(params) {
        this.params = params;
    }
    static fromTemplate(template) {
        return new TemplateParameters(template.Parameters || {});
    }
    /**
     * Calculate stack parameters to pass from the given desired parameter values
     *
     * Will throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    supplyAll(updates) {
        return new ParameterValues(this.params, updates);
    }
    /**
     * From the template, the given desired values and the current values, calculate the changes to the stack parameters
     *
     * Will take into account parameters already set on the template (will emit
     * 'UsePreviousValue: true' for those unless the value is changed), and will
     * throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    updateExisting(updates, previousValues) {
        return new ParameterValues(this.params, updates, previousValues);
    }
}
exports.TemplateParameters = TemplateParameters;
/**
 * The set of parameters we're going to pass to a Stack
 */
class ParameterValues {
    constructor(formalParams, updates, previousValues = {}) {
        this.formalParams = formalParams;
        this.values = {};
        this.apiParameters = [];
        const missingRequired = new Array();
        for (const [key, formalParam] of Object.entries(this.formalParams)) {
            // Check updates first, then use the previous value (if available), then use
            // the default (if available).
            //
            // If we don't find a parameter value using any of these methods, then that's an error.
            const updatedValue = updates[key];
            if (updatedValue !== undefined) {
                this.values[key] = updatedValue;
                this.apiParameters.push({ ParameterKey: key, ParameterValue: updates[key] });
                continue;
            }
            if (key in previousValues) {
                this.values[key] = previousValues[key];
                this.apiParameters.push({ ParameterKey: key, UsePreviousValue: true });
                continue;
            }
            if (formalParam.Default !== undefined) {
                this.values[key] = formalParam.Default;
                continue;
            }
            // Oh no
            missingRequired.push(key);
        }
        if (missingRequired.length > 0) {
            throw new Error(`The following CloudFormation Parameters are missing a value: ${missingRequired.join(', ')}`);
        }
        // Just append all supplied overrides that aren't really expected (this
        // will fail CFN but maybe people made typos that they want to be notified
        // of)
        const unknownParam = ([key, _]) => this.formalParams[key] === undefined;
        const hasValue = ([_, value]) => !!value;
        for (const [key, value] of Object.entries(updates).filter(unknownParam).filter(hasValue)) {
            this.values[key] = value;
            this.apiParameters.push({ ParameterKey: key, ParameterValue: value });
        }
    }
    /**
     * Whether this set of parameter updates will change the actual stack values
     */
    hasChanges(currentValues) {
        // If any of the parameters are SSM parameters, deploying must always happen
        // because we can't predict what the values will be. We will allow some
        // parameters to opt out of this check by having a magic string in their description.
        if (Object.values(this.formalParams).some(p => p.Type.startsWith('AWS::SSM::Parameter::') && !p.Description?.includes(cx_api_1.SSMPARAM_NO_INVALIDATE))) {
            return 'ssm';
        }
        // Otherwise we're dirty if:
        // - any of the existing values are removed, or changed
        if (Object.entries(currentValues).some(([key, value]) => !(key in this.values) || value !== this.values[key])) {
            return true;
        }
        // - any of the values we're setting are new
        if (Object.keys(this.values).some(key => !(key in currentValues))) {
            return true;
        }
        return false;
    }
}
exports.ParameterValues = ParameterValues;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbG91ZGZvcm1hdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw0Q0FBeUQ7QUFFekQsMkNBQXNDO0FBQ3RDLCtDQUF1RDtBQUN2RCxnRUFBNEQ7QUFrQjVEOzs7OztHQUtHO0FBQ0gsTUFBYSxtQkFBbUI7SUFpQzlCLFlBQ21CLEdBQW1CLEVBQWtCLFNBQWlCLEVBQW1CLEtBQTRCLEVBQ3JHLDRCQUFxQyxLQUFLO1FBRDFDLFFBQUcsR0FBSCxHQUFHLENBQWdCO1FBQWtCLGNBQVMsR0FBVCxTQUFTLENBQVE7UUFBbUIsVUFBSyxHQUFMLEtBQUssQ0FBdUI7UUFDckcsOEJBQXlCLEdBQXpCLHlCQUF5QixDQUFpQjtJQUU3RCxDQUFDO0lBcENNLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUN4QixHQUFtQixFQUFFLFNBQWlCLEVBQUUsNEJBQXFDLEtBQUs7UUFFbEYsSUFBSTtZQUNGLE1BQU0sUUFBUSxHQUFHLE1BQU0sR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzlFLE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLFFBQVEsQ0FBQyxNQUFNLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO1NBQ2xIO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssaUJBQWlCLElBQUksQ0FBQyxDQUFDLE9BQU8sS0FBSyxpQkFBaUIsU0FBUyxpQkFBaUIsRUFBRTtnQkFDN0YsT0FBTyxJQUFJLG1CQUFtQixDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7YUFDM0Q7WUFDRCxNQUFNLENBQUMsQ0FBQztTQUNUO0lBQ0gsQ0FBQztJQUVE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USxDQUFDLCtCQUFzQixDQUFDLENBQUMsRUFBRTtZQUM5SSxPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsNEJBQTRCO1FBQzVCLHVEQUF1RDtRQUN2RCxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7WUFDN0csT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELDRDQUE0QztRQUM1QyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksYUFBYSxDQUFDLENBQUMsRUFBRTtZQUNqRSxPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUE3RUQsMENBNkVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU1NNUEFSQU1fTk9fSU5WQUxJREFURSB9IGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvbiB9IGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IGRlc2VyaWFsaXplU3RydWN0dXJlIH0gZnJvbSAnLi4vLi4vc2VyaWFsaXplJztcbmltcG9ydCB7IFN0YWNrU3RhdHVzIH0gZnJvbSAnLi9jbG91ZGZvcm1hdGlvbi9zdGFjay1zdGF0dXMnO1xuXG5leHBvcnQgdHlwZSBUZW1wbGF0ZSA9IHtcbiAgUGFyYW1ldGVycz86IFJlY29yZDxzdHJpbmcsIFRlbXBsYXRlUGFyYW1ldGVyPjtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufTtcblxuaW50ZXJmYWNlIFRlbXBsYXRlUGFyYW1ldGVyIHtcbiAgVHlwZTogc3RyaW5nO1xuICBEZWZhdWx0PzogYW55O1xuICBEZXNjcmlwdGlvbj86IHN0cmluZztcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgdHlwZSBSZXNvdXJjZUlkZW50aWZpZXJQcm9wZXJ0aWVzID0gQ2xvdWRGb3JtYXRpb24uUmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcztcbmV4cG9ydCB0eXBlIFJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyA9IENsb3VkRm9ybWF0aW9uLlJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcztcbmV4cG9ydCB0eXBlIFJlc291cmNlc1RvSW1wb3J0ID0gQ2xvdWRGb3JtYXRpb24uUmVzb3VyY2VzVG9JbXBvcnQ7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiAoZXhpc3RpbmcpIFN0YWNrIGluIENsb3VkRm9ybWF0aW9uXG4gKlxuICogQnVuZGxlIGFuZCBjYWNoZSBzb21lIGluZm9ybWF0aW9uIHRoYXQgd2UgbmVlZCBkdXJpbmcgZGVwbG95bWVudCAoc28gd2UgZG9uJ3QgaGF2ZSB0byBtYWtlXG4gKiByZXBlYXRlZCBjYWxscyB0byBDbG91ZEZvcm1hdGlvbikuXG4gKi9cbmV4cG9ydCBjbGFzcyBDbG91ZEZvcm1hdGlvblN0YWNrIHtcbiAgcHVibGljIHN0YXRpYyBhc3luYyBsb29rdXAoXG4gICAgY2ZuOiBDbG91ZEZvcm1hdGlvbiwgc3RhY2tOYW1lOiBzdHJpbmcsIHJldHJpZXZlUHJvY2Vzc2VkVGVtcGxhdGU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvblN0YWNrPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2ZuLmRlc2NyaWJlU3RhY2tzKHsgU3RhY2tOYW1lOiBzdGFja05hbWUgfSkucHJvbWlzZSgpO1xuICAgICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lLCByZXNwb25zZS5TdGFja3MgJiYgcmVzcG9uc2UuU3RhY2tzWzBdLCByZXRyaWV2ZVByb2Nlc3NlZFRlbXBsYXRlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlID09PSAnVmFsaWRhdGlvbkVycm9yJyAmJiBlLm1lc3NhZ2UgPT09IGBTdGFjayB3aXRoIGlkICR7c3RhY2tOYW1lfSBkb2VzIG5vdCBleGlzdGApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgY29weSBvZiB0aGUgZ2l2ZW4gc3RhY2sgdGhhdCBkb2VzIG5vdCBleGlzdFxuICAgKlxuICAgKiBJdCdzIGEgbGl0dGxlIHNpbGx5IHRoYXQgaXQgbmVlZHMgYXJndW1lbnRzIHRvIGRvIHRoYXQsIGJ1dCB0aGVyZSB3ZSBnby5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZG9lc05vdEV4aXN0KGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcm9tIHN0YXRpYyBpbmZvcm1hdGlvbiAoZm9yIHRlc3RpbmcpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21TdGF0aWNJbmZvcm1hdGlvbihjZm46IENsb3VkRm9ybWF0aW9uLCBzdGFja05hbWU6IHN0cmluZywgc3RhY2s6IENsb3VkRm9ybWF0aW9uLlN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lLCBzdGFjayk7XG4gIH1cblxuICBwcml2YXRlIF90ZW1wbGF0ZTogYW55O1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNmbjogQ2xvdWRGb3JtYXRpb24sIHB1YmxpYyByZWFkb25seSBzdGFja05hbWU6IHN0cmluZywgcHJpdmF0ZSByZWFkb25seSBzdGFjaz86IENsb3VkRm9ybWF0aW9uLlN0YWNrLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcmV0cmlldmVQcm9jZXNzZWRUZW1wbGF0ZTogYm9vbGVhbiA9IGZhbHNlLFxuICApIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgc3RhY2sncyBkZXBsb3llZCB0ZW1wbGF0ZVxuICAgKlxuICAgKiBDYWNoZWQsIHNvIHdpbGwgb25seSBiZSByZXRyaWV2ZWQgb25jZS4gV2lsbCByZXR1cm4gYW4gZW1wdHlcbiAgICogc3RydWN0dXJlIGlmIHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB0ZW1wbGF0ZSgpOiBQcm9taXNlPFRlbXBsYXRlPiB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90ZW1wbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2ZuLmdldFRlbXBsYXRlKHtcbiAgICAgICAgU3RhY2tOYW1lOiB0aGlzLnN0YWNrTmFtZSxcbiAgICAgICAgVGVtcGxhdGVTdGFnZTogdGhpcy5yZXRyaWV2ZVByb2Nlc3NlZFRlbXBsYXRlID8gJ1Byb2Nlc3NlZCcgOiAnT3JpZ2luYWwnLFxuICAgICAgfSkucHJvbWlzZSgpO1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSAocmVzcG9uc2UuVGVtcGxhdGVCb2R5ICYmIGRlc2VyaWFsaXplU3RydWN0dXJlKHJlc3BvbnNlLlRlbXBsYXRlQm9keSkpIHx8IHt9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc3RhY2sgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgZ2V0IGV4aXN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjayAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFjaydzIElEXG4gICAqXG4gICAqIFRocm93cyBpZiB0aGUgc3RhY2sgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhY2tJZCgpIHtcbiAgICB0aGlzLmFzc2VydEV4aXN0cygpO1xuICAgIHJldHVybiB0aGlzLnN0YWNrIS5TdGFja0lkITtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sncyBjdXJyZW50IG91dHB1dHNcbiAgICpcbiAgICogRW1wdHkgb2JqZWN0IGlmIHRoZSBzdGFjayBkb2Vzbid0IGV4aXN0XG4gICAqL1xuICBwdWJsaWMgZ2V0IG91dHB1dHMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykgeyByZXR1cm4ge307IH1cbiAgICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgKHRoaXMuc3RhY2shLk91dHB1dHMgfHwgW10pLmZvckVhY2gob3V0cHV0ID0+IHtcbiAgICAgIHJlc3VsdFtvdXRwdXQuT3V0cHV0S2V5IV0gPSBvdXRwdXQuT3V0cHV0VmFsdWUhO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0YWNrJ3Mgc3RhdHVzXG4gICAqXG4gICAqIFNwZWNpYWwgc3RhdHVzIE5PVF9GT1VORCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YWNrU3RhdHVzKCk6IFN0YWNrU3RhdHVzIHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7XG4gICAgICByZXR1cm4gbmV3IFN0YWNrU3RhdHVzKCdOT1RfRk9VTkQnLCAnU3RhY2sgbm90IGZvdW5kIGR1cmluZyBsb29rdXAnKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrU3RhdHVzLmZyb21TdGFja0Rlc2NyaXB0aW9uKHRoaXMuc3RhY2shKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sncyBjdXJyZW50IHRhZ3NcbiAgICpcbiAgICogRW1wdHkgbGlzdCBvZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3RcbiAgICovXG4gIHB1YmxpYyBnZXQgdGFncygpOiBDbG91ZEZvcm1hdGlvbi5UYWdzIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjaz8uVGFncyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5hbWVzIG9mIGFsbCBjdXJyZW50IHBhcmFtZXRlcnMgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEVtcHR5IGxpc3QgaWYgdGhlIHN0YWNrIGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgcHVibGljIGdldCBwYXJhbWV0ZXJOYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucGFyYW1ldGVycyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGFsbCBjdXJyZW50IHBhcmFtZXRlcnMgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEVtcHR5IG9iamVjdCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBhcmFtZXRlcnMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykgeyByZXR1cm4ge307IH1cbiAgICBjb25zdCByZXQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHRoaXMuc3RhY2shLlBhcmFtZXRlcnMgPz8gW10pIHtcbiAgICAgIHJldFtwYXJhbS5QYXJhbWV0ZXJLZXkhXSA9IHBhcmFtLlBhcmFtZXRlclZhbHVlITtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRlcm1pbmF0aW9uIHByb3RlY3Rpb24gb2YgdGhlIHN0YWNrXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRlcm1pbmF0aW9uUHJvdGVjdGlvbigpOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjaz8uRW5hYmxlVGVybWluYXRpb25Qcm90ZWN0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3NlcnRFeGlzdHMoKSB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGFjayBuYW1lZCAnJHt0aGlzLnN0YWNrTmFtZX0nYCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGVzY3JpYmUgYSBjaGFuZ2VzZXQgaW4gQ2xvdWRGb3JtYXRpb24sIHJlZ2FyZGxlc3Mgb2YgaXRzIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgIHRoZSBuYW1lIG9mIHRoZSBTdGFjayB0aGUgQ2hhbmdlU2V0IGJlbG9uZ3MgdG9cbiAqIEBwYXJhbSBjaGFuZ2VTZXROYW1lIHRoZSBuYW1lIG9mIHRoZSBDaGFuZ2VTZXRcbiAqIEBwYXJhbSBmZXRjaEFsbCAgICAgIGlmIHRydWUsIGZldGNoZXMgYWxsIHBhZ2VzIG9mIHRoZSBjaGFuZ2Ugc2V0IGRlc2NyaXB0aW9uLlxuICpcbiAqIEByZXR1cm5zICAgICAgIENsb3VkRm9ybWF0aW9uIGluZm9ybWF0aW9uIGFib3V0IHRoZSBDaGFuZ2VTZXRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVzY3JpYmVDaGFuZ2VTZXQoXG4gIGNmbjogQ2xvdWRGb3JtYXRpb24sXG4gIHN0YWNrTmFtZTogc3RyaW5nLFxuICBjaGFuZ2VTZXROYW1lOiBzdHJpbmcsXG4gIHsgZmV0Y2hBbGwgfTogeyBmZXRjaEFsbDogYm9vbGVhbiB9LFxuKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5EZXNjcmliZUNoYW5nZVNldE91dHB1dD4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNmbi5kZXNjcmliZUNoYW5nZVNldCh7IFN0YWNrTmFtZTogc3RhY2tOYW1lLCBDaGFuZ2VTZXROYW1lOiBjaGFuZ2VTZXROYW1lIH0pLnByb21pc2UoKTtcblxuICAvLyBJZiBmZXRjaEFsbCBpcyB0cnVlLCB0cmF2ZXJzZSBhbGwgcGFnZXMgZnJvbSB0aGUgY2hhbmdlIHNldCBkZXNjcmlwdGlvbi5cbiAgd2hpbGUgKGZldGNoQWxsICYmIHJlc3BvbnNlLk5leHRUb2tlbiAhPSBudWxsKSB7XG4gICAgY29uc3QgbmV4dFBhZ2UgPSBhd2FpdCBjZm4uZGVzY3JpYmVDaGFuZ2VTZXQoe1xuICAgICAgU3RhY2tOYW1lOiBzdGFja05hbWUsXG4gICAgICBDaGFuZ2VTZXROYW1lOiByZXNwb25zZS5DaGFuZ2VTZXRJZCA/PyBjaGFuZ2VTZXROYW1lLFxuICAgICAgTmV4dFRva2VuOiByZXNwb25zZS5OZXh0VG9rZW4sXG4gICAgfSkucHJvbWlzZSgpO1xuXG4gICAgLy8gQ29uc29saWRhdGUgdGhlIGNoYW5nZXNcbiAgICBpZiAobmV4dFBhZ2UuQ2hhbmdlcyAhPSBudWxsKSB7XG4gICAgICByZXNwb25zZS5DaGFuZ2VzID0gcmVzcG9uc2UuQ2hhbmdlcyAhPSBudWxsXG4gICAgICAgID8gcmVzcG9uc2UuQ2hhbmdlcy5jb25jYXQobmV4dFBhZ2UuQ2hhbmdlcylcbiAgICAgICAgOiBuZXh0UGFnZS5DaGFuZ2VzO1xuICAgIH1cblxuICAgIC8vIEZvcndhcmQgdGhlIG5ldyBOZXh0VG9rZW5cbiAgICByZXNwb25zZS5OZXh0VG9rZW4gPSBuZXh0UGFnZS5OZXh0VG9rZW47XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgZnVuY3Rpb24gdG8gcmV0dXJuIG5vbi0rdW5kZWZpbmVkKyBiZWZvcmUgcmV0dXJuaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVByb3ZpZGVyIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHVybiBhIHZhbHVlIHRoYXQgaXMgbm90ICt1bmRlZmluZWQrIG9uY2UgdGhlIHdhaXQgc2hvdWxkIGJlIG92ZXJcbiAqIEBwYXJhbSB0aW1lb3V0ICAgICB0aGUgdGltZSB0byB3YWl0IGJldHdlZW4gdHdvIGNhbGxzIHRvICt2YWx1ZVByb3ZpZGVyK1xuICpcbiAqIEByZXR1cm5zICAgICAgIHRoZSB2YWx1ZSB0aGF0IHdhcyByZXR1cm5lZCBieSArdmFsdWVQcm92aWRlcitcbiAqL1xuYXN5bmMgZnVuY3Rpb24gd2FpdEZvcjxUPih2YWx1ZVByb3ZpZGVyOiAoKSA9PiBQcm9taXNlPFQgfCBudWxsIHwgdW5kZWZpbmVkPiwgdGltZW91dDogbnVtYmVyID0gNTAwMCk6IFByb21pc2U8VCB8IHVuZGVmaW5lZD4ge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbHVlUHJvdmlkZXIoKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKGNiID0+IHNldFRpbWVvdXQoY2IsIHRpbWVvdXQpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIENoYW5nZVNldCB0byBiZSBhdmFpbGFibGUgZm9yIHRyaWdnZXJpbmcgYSBTdGFja1VwZGF0ZS5cbiAqXG4gKiBXaWxsIHJldHVybiBhIGNoYW5nZXNldCB0aGF0IGlzIGVpdGhlciByZWFkeSB0byBiZSBleGVjdXRlZCBvciBoYXMgbm8gY2hhbmdlcy5cbiAqIFdpbGwgdGhyb3cgaW4gb3RoZXIgY2FzZXMuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgIHRoZSBuYW1lIG9mIHRoZSBTdGFjayB0aGF0IHRoZSBDaGFuZ2VTZXQgYmVsb25ncyB0b1xuICogQHBhcmFtIGNoYW5nZVNldE5hbWUgdGhlIG5hbWUgb2YgdGhlIENoYW5nZVNldFxuICogQHBhcmFtIGZldGNoQWxsICAgICAgaWYgdHJ1ZSwgZmV0Y2hlcyBhbGwgcGFnZXMgb2YgdGhlIENoYW5nZVNldCBiZWZvcmUgcmV0dXJuaW5nLlxuICpcbiAqIEByZXR1cm5zICAgICAgIHRoZSBDbG91ZEZvcm1hdGlvbiBkZXNjcmlwdGlvbiBvZiB0aGUgQ2hhbmdlU2V0XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvckNoYW5nZVNldChcbiAgY2ZuOiBDbG91ZEZvcm1hdGlvbixcbiAgc3RhY2tOYW1lOiBzdHJpbmcsXG4gIGNoYW5nZVNldE5hbWU6IHN0cmluZyxcbiAgeyBmZXRjaEFsbCB9OiB7IGZldGNoQWxsOiBib29sZWFuIH0sXG4pOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uLkRlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0PiB7XG4gIGRlYnVnKCdXYWl0aW5nIGZvciBjaGFuZ2VzZXQgJXMgb24gc3RhY2sgJXMgdG8gZmluaXNoIGNyZWF0aW5nLi4uJywgY2hhbmdlU2V0TmFtZSwgc3RhY2tOYW1lKTtcbiAgY29uc3QgcmV0ID0gYXdhaXQgd2FpdEZvcihhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBhd2FpdCBkZXNjcmliZUNoYW5nZVNldChjZm4sIHN0YWNrTmFtZSwgY2hhbmdlU2V0TmFtZSwgeyBmZXRjaEFsbCB9KTtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGRvZXNuJ3QgdXNlIGEgc3dpdGNoIGJlY2F1c2UgdHNjIHdpbGwgbm90IGFsbG93IGZhbGwtdGhyb3VnaCwgVU5MRVNTIGl0IGlzIGFsbG93c1xuICAgIC8vIEVWRVJZV0hFUkUgdGhhdCB1c2VzIHRoaXMgbGlicmFyeSBkaXJlY3RseSBvciBpbmRpcmVjdGx5LCB3aGljaCBpcyB1bmRlc2lyYWJsZS5cbiAgICBpZiAoZGVzY3JpcHRpb24uU3RhdHVzID09PSAnQ1JFQVRFX1BFTkRJTkcnIHx8IGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0NSRUFURV9JTl9QUk9HUkVTUycpIHtcbiAgICAgIGRlYnVnKCdDaGFuZ2VzZXQgJXMgb24gc3RhY2sgJXMgaXMgc3RpbGwgY3JlYXRpbmcnLCBjaGFuZ2VTZXROYW1lLCBzdGFja05hbWUpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZGVzY3JpcHRpb24uU3RhdHVzID09PSAnQ1JFQVRFX0NPTVBMRVRFJyB8fCBjaGFuZ2VTZXRIYXNOb0NoYW5nZXMoZGVzY3JpcHRpb24pKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgQ2hhbmdlU2V0ICR7Y2hhbmdlU2V0TmFtZX0gb24gJHtzdGFja05hbWV9OiAke2Rlc2NyaXB0aW9uLlN0YXR1cyB8fCAnTk9fU1RBVFVTJ30sICR7ZGVzY3JpcHRpb24uU3RhdHVzUmVhc29uIHx8ICdubyByZWFzb24gcHJvdmlkZWQnfWApO1xuICB9KTtcblxuICBpZiAoIXJldCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2hhbmdlIHNldCB0b29rIHRvbyBsb25nIHRvIGJlIGNyZWF0ZWQ7IGFib3J0aW5nJyk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBjaGFuZ2Ugc2V0IGhhcyBubyBjaGFuZ2VzXG4gKlxuICogVGhpcyBtdXN0IGJlIGRldGVybWluZWQgZnJvbSB0aGUgc3RhdHVzLCBub3QgdGhlICdDaGFuZ2VzJyBhcnJheSBvbiB0aGVcbiAqIG9iamVjdDsgdGhlIGxhdHRlciBjYW4gYmUgZW1wdHkgYmVjYXVzZSBubyByZXNvdXJjZXMgd2VyZSBjaGFuZ2VkLCBidXQgaWZcbiAqIHRoZXJlIGFyZSBjaGFuZ2VzIHRvIE91dHB1dHMsIHRoZSBjaGFuZ2Ugc2V0IGNhbiBzdGlsbCBiZSBleGVjdXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoYW5nZVNldEhhc05vQ2hhbmdlcyhkZXNjcmlwdGlvbjogQ2xvdWRGb3JtYXRpb24uRGVzY3JpYmVDaGFuZ2VTZXRPdXRwdXQpIHtcbiAgY29uc3Qgbm9DaGFuZ2VFcnJvclByZWZpeGVzID0gW1xuICAgIC8vIEVycm9yIG1lc3NhZ2UgZm9yIGEgcmVndWxhciB0ZW1wbGF0ZVxuICAgICdUaGUgc3VibWl0dGVkIGluZm9ybWF0aW9uIGRpZG5cXCd0IGNvbnRhaW4gY2hhbmdlcy4nLFxuICAgIC8vIEVycm9yIG1lc3NhZ2Ugd2hlbiBhIFRyYW5zZm9ybSBpcyBpbnZvbHZlZCAoc2VlICMxMDY1MClcbiAgICAnTm8gdXBkYXRlcyBhcmUgdG8gYmUgcGVyZm9ybWVkLicsXG4gIF07XG5cbiAgcmV0dXJuIGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0ZBSUxFRCdcbiAgICAmJiBub0NoYW5nZUVycm9yUHJlZml4ZXMuc29tZShwID0+IChkZXNjcmlwdGlvbi5TdGF0dXNSZWFzb24gPz8gJycpLnN0YXJ0c1dpdGgocCkpO1xufVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIENsb3VkRm9ybWF0aW9uIHN0YWNrIHRvIHN0YWJpbGl6ZSBpbiBhIGNvbXBsZXRlL2F2YWlsYWJsZSBzdGF0ZVxuICogYWZ0ZXIgYSBkZWxldGUgb3BlcmF0aW9uIGlzIGlzc3VlZC5cbiAqXG4gKiBGYWlscyBpZiB0aGUgc3RhY2sgaXMgaW4gYSBGQUlMRUQgc3RhdGUuIFdpbGwgbm90IGZhaWwgaWYgdGhlIHN0YWNrIHdhc1xuICogYWxyZWFkeSBkZWxldGVkLlxuICpcbiAqIEBwYXJhbSBjZm4gICAgICAgIGEgQ2xvdWRGb3JtYXRpb24gY2xpZW50XG4gKiBAcGFyYW0gc3RhY2tOYW1lICAgICAgdGhlIG5hbWUgb2YgdGhlIHN0YWNrIHRvIHdhaXQgZm9yIGFmdGVyIGEgZGVsZXRlXG4gKlxuICogQHJldHVybnMgICAgIHRoZSBDbG91ZEZvcm1hdGlvbiBkZXNjcmlwdGlvbiBvZiB0aGUgc3RhYmlsaXplZCBzdGFjayBhZnRlciB0aGUgZGVsZXRlIGF0dGVtcHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JTdGFja0RlbGV0ZShcbiAgY2ZuOiBDbG91ZEZvcm1hdGlvbixcbiAgc3RhY2tOYW1lOiBzdHJpbmcpOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uU3RhY2sgfCB1bmRlZmluZWQ+IHtcblxuICBjb25zdCBzdGFjayA9IGF3YWl0IHN0YWJpbGl6ZVN0YWNrKGNmbiwgc3RhY2tOYW1lKTtcbiAgaWYgKCFzdGFjaykgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgY29uc3Qgc3RhdHVzID0gc3RhY2suc3RhY2tTdGF0dXM7XG4gIGlmIChzdGF0dXMuaXNGYWlsdXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc3RhY2sgbmFtZWQgJHtzdGFja05hbWV9IGlzIGluIGEgZmFpbGVkIHN0YXRlLiBZb3UgbWF5IG5lZWQgdG8gZGVsZXRlIGl0IGZyb20gdGhlIEFXUyBjb25zb2xlIDogJHtzdGF0dXN9YCk7XG4gIH0gZWxzZSBpZiAoc3RhdHVzLmlzRGVsZXRlZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHN0YWNrO1xufVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIENsb3VkRm9ybWF0aW9uIHN0YWNrIHRvIHN0YWJpbGl6ZSBpbiBhIGNvbXBsZXRlL2F2YWlsYWJsZSBzdGF0ZVxuICogYWZ0ZXIgYW4gdXBkYXRlL2NyZWF0ZSBvcGVyYXRpb24gaXMgaXNzdWVkLlxuICpcbiAqIEZhaWxzIGlmIHRoZSBzdGFjayBpcyBpbiBhIEZBSUxFRCBzdGF0ZSwgUk9MTEJBQ0sgc3RhdGUsIG9yIERFTEVURUQgc3RhdGUuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgICB0aGUgbmFtZSBvZiB0aGUgc3RhY2sgdG8gd2FpdCBmb3IgYWZ0ZXIgYW4gdXBkYXRlXG4gKlxuICogQHJldHVybnMgICAgIHRoZSBDbG91ZEZvcm1hdGlvbiBkZXNjcmlwdGlvbiBvZiB0aGUgc3RhYmlsaXplZCBzdGFjayBhZnRlciB0aGUgdXBkYXRlIGF0dGVtcHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JTdGFja0RlcGxveShcbiAgY2ZuOiBDbG91ZEZvcm1hdGlvbixcbiAgc3RhY2tOYW1lOiBzdHJpbmcpOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uU3RhY2sgfCB1bmRlZmluZWQ+IHtcblxuICBjb25zdCBzdGFjayA9IGF3YWl0IHN0YWJpbGl6ZVN0YWNrKGNmbiwgc3RhY2tOYW1lKTtcbiAgaWYgKCFzdGFjaykgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgY29uc3Qgc3RhdHVzID0gc3RhY2suc3RhY2tTdGF0dXM7XG5cbiAgaWYgKHN0YXR1cy5pc0NyZWF0aW9uRmFpbHVyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN0YWNrIG5hbWVkICR7c3RhY2tOYW1lfSBmYWlsZWQgY3JlYXRpb24sIGl0IG1heSBuZWVkIHRvIGJlIG1hbnVhbGx5IGRlbGV0ZWQgZnJvbSB0aGUgQVdTIGNvbnNvbGU6ICR7c3RhdHVzfWApO1xuICB9IGVsc2UgaWYgKCFzdGF0dXMuaXNEZXBsb3lTdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc3RhY2sgbmFtZWQgJHtzdGFja05hbWV9IGZhaWxlZCB0byBkZXBsb3k6ICR7c3RhdHVzfWApO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrO1xufVxuXG4vKipcbiAqIFdhaXQgZm9yIGEgc3RhY2sgdG8gYmVjb21lIHN0YWJsZSAobm8gbG9uZ2VyIF9JTl9QUk9HUkVTUyksIHJldHVybmluZyBpdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhYmlsaXplU3RhY2soY2ZuOiBDbG91ZEZvcm1hdGlvbiwgc3RhY2tOYW1lOiBzdHJpbmcpIHtcbiAgZGVidWcoJ1dhaXRpbmcgZm9yIHN0YWNrICVzIHRvIGZpbmlzaCBjcmVhdGluZyBvciB1cGRhdGluZy4uLicsIHN0YWNrTmFtZSk7XG4gIHJldHVybiB3YWl0Rm9yKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBzdGFjayA9IGF3YWl0IENsb3VkRm9ybWF0aW9uU3RhY2subG9va3VwKGNmbiwgc3RhY2tOYW1lKTtcbiAgICBpZiAoIXN0YWNrLmV4aXN0cykge1xuICAgICAgZGVidWcoJ1N0YWNrICVzIGRvZXMgbm90IGV4aXN0Jywgc3RhY2tOYW1lKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSBzdGFjay5zdGFja1N0YXR1cztcbiAgICBpZiAoc3RhdHVzLmlzSW5Qcm9ncmVzcykge1xuICAgICAgZGVidWcoJ1N0YWNrICVzIGhhcyBhbiBvbmdvaW5nIG9wZXJhdGlvbiBpbiBwcm9ncmVzcyBhbmQgaXMgbm90IHN0YWJsZSAoJXMpJywgc3RhY2tOYW1lLCBzdGF0dXMpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZSBzZXQgb2YgKGZvcm1hbCkgcGFyYW1ldGVycyB0aGF0IGhhdmUgYmVlbiBkZWNsYXJlZCBpbiBhIHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZVBhcmFtZXRlcnMge1xuICBwdWJsaWMgc3RhdGljIGZyb21UZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGUpIHtcbiAgICByZXR1cm4gbmV3IFRlbXBsYXRlUGFyYW1ldGVycyh0ZW1wbGF0ZS5QYXJhbWV0ZXJzIHx8IHt9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBUZW1wbGF0ZVBhcmFtZXRlcj4pIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgc3RhY2sgcGFyYW1ldGVycyB0byBwYXNzIGZyb20gdGhlIGdpdmVuIGRlc2lyZWQgcGFyYW1ldGVyIHZhbHVlc1xuICAgKlxuICAgKiBXaWxsIHRocm93IGlmIHBhcmFtZXRlcnMgd2l0aG91dCBhIERlZmF1bHQgdmFsdWUgb3IgYSBQcmV2aW91cyB2YWx1ZSBhcmUgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKi9cbiAgcHVibGljIHN1cHBseUFsbCh1cGRhdGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+KTogUGFyYW1ldGVyVmFsdWVzIHtcbiAgICByZXR1cm4gbmV3IFBhcmFtZXRlclZhbHVlcyh0aGlzLnBhcmFtcywgdXBkYXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogRnJvbSB0aGUgdGVtcGxhdGUsIHRoZSBnaXZlbiBkZXNpcmVkIHZhbHVlcyBhbmQgdGhlIGN1cnJlbnQgdmFsdWVzLCBjYWxjdWxhdGUgdGhlIGNoYW5nZXMgdG8gdGhlIHN0YWNrIHBhcmFtZXRlcnNcbiAgICpcbiAgICogV2lsbCB0YWtlIGludG8gYWNjb3VudCBwYXJhbWV0ZXJzIGFscmVhZHkgc2V0IG9uIHRoZSB0ZW1wbGF0ZSAod2lsbCBlbWl0XG4gICAqICdVc2VQcmV2aW91c1ZhbHVlOiB0cnVlJyBmb3IgdGhvc2UgdW5sZXNzIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkKSwgYW5kIHdpbGxcbiAgICogdGhyb3cgaWYgcGFyYW1ldGVycyB3aXRob3V0IGEgRGVmYXVsdCB2YWx1ZSBvciBhIFByZXZpb3VzIHZhbHVlIGFyZSBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlRXhpc3RpbmcodXBkYXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPiwgcHJldmlvdXNWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBQYXJhbWV0ZXJWYWx1ZXMge1xuICAgIHJldHVybiBuZXcgUGFyYW1ldGVyVmFsdWVzKHRoaXMucGFyYW1zLCB1cGRhdGVzLCBwcmV2aW91c1ZhbHVlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgc2V0IG9mIHBhcmFtZXRlcnMgd2UncmUgZ29pbmcgdG8gcGFzcyB0byBhIFN0YWNrXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJhbWV0ZXJWYWx1ZXMge1xuICBwdWJsaWMgcmVhZG9ubHkgdmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIHB1YmxpYyByZWFkb25seSBhcGlQYXJhbWV0ZXJzOiBDbG91ZEZvcm1hdGlvbi5QYXJhbWV0ZXJbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZm9ybWFsUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBUZW1wbGF0ZVBhcmFtZXRlcj4sXG4gICAgdXBkYXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPixcbiAgICBwcmV2aW91c1ZhbHVlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9KSB7XG5cbiAgICBjb25zdCBtaXNzaW5nUmVxdWlyZWQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBba2V5LCBmb3JtYWxQYXJhbV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5mb3JtYWxQYXJhbXMpKSB7XG4gICAgICAvLyBDaGVjayB1cGRhdGVzIGZpcnN0LCB0aGVuIHVzZSB0aGUgcHJldmlvdXMgdmFsdWUgKGlmIGF2YWlsYWJsZSksIHRoZW4gdXNlXG4gICAgICAvLyB0aGUgZGVmYXVsdCAoaWYgYXZhaWxhYmxlKS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIGEgcGFyYW1ldGVyIHZhbHVlIHVzaW5nIGFueSBvZiB0aGVzZSBtZXRob2RzLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbiAgICAgIGNvbnN0IHVwZGF0ZWRWYWx1ZSA9IHVwZGF0ZXNba2V5XTtcbiAgICAgIGlmICh1cGRhdGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gdXBkYXRlZFZhbHVlO1xuICAgICAgICB0aGlzLmFwaVBhcmFtZXRlcnMucHVzaCh7IFBhcmFtZXRlcktleToga2V5LCBQYXJhbWV0ZXJWYWx1ZTogdXBkYXRlc1trZXldIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSBpbiBwcmV2aW91c1ZhbHVlcykge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gcHJldmlvdXNWYWx1ZXNba2V5XTtcbiAgICAgICAgdGhpcy5hcGlQYXJhbWV0ZXJzLnB1c2goeyBQYXJhbWV0ZXJLZXk6IGtleSwgVXNlUHJldmlvdXNWYWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYWxQYXJhbS5EZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNba2V5XSA9IGZvcm1hbFBhcmFtLkRlZmF1bHQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBPaCBub1xuICAgICAgbWlzc2luZ1JlcXVpcmVkLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBpZiAobWlzc2luZ1JlcXVpcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBDbG91ZEZvcm1hdGlvbiBQYXJhbWV0ZXJzIGFyZSBtaXNzaW5nIGEgdmFsdWU6ICR7bWlzc2luZ1JlcXVpcmVkLmpvaW4oJywgJyl9YCk7XG4gICAgfVxuXG4gICAgLy8gSnVzdCBhcHBlbmQgYWxsIHN1cHBsaWVkIG92ZXJyaWRlcyB0aGF0IGFyZW4ndCByZWFsbHkgZXhwZWN0ZWQgKHRoaXNcbiAgICAvLyB3aWxsIGZhaWwgQ0ZOIGJ1dCBtYXliZSBwZW9wbGUgbWFkZSB0eXBvcyB0aGF0IHRoZXkgd2FudCB0byBiZSBub3RpZmllZFxuICAgIC8vIG9mKVxuICAgIGNvbnN0IHVua25vd25QYXJhbSA9IChba2V5LCBfXTogW3N0cmluZywgYW55XSkgPT4gdGhpcy5mb3JtYWxQYXJhbXNba2V5XSA9PT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGhhc1ZhbHVlID0gKFtfLCB2YWx1ZV06IFtzdHJpbmcsIGFueV0pID0+ICEhdmFsdWU7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModXBkYXRlcykuZmlsdGVyKHVua25vd25QYXJhbSkuZmlsdGVyKGhhc1ZhbHVlKSkge1xuICAgICAgdGhpcy52YWx1ZXNba2V5XSA9IHZhbHVlITtcbiAgICAgIHRoaXMuYXBpUGFyYW1ldGVycy5wdXNoKHsgUGFyYW1ldGVyS2V5OiBrZXksIFBhcmFtZXRlclZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIHNldCBvZiBwYXJhbWV0ZXIgdXBkYXRlcyB3aWxsIGNoYW5nZSB0aGUgYWN0dWFsIHN0YWNrIHZhbHVlc1xuICAgKi9cbiAgcHVibGljIGhhc0NoYW5nZXMoY3VycmVudFZhbHVlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IFBhcmFtZXRlckNoYW5nZXMge1xuICAgIC8vIElmIGFueSBvZiB0aGUgcGFyYW1ldGVycyBhcmUgU1NNIHBhcmFtZXRlcnMsIGRlcGxveWluZyBtdXN0IGFsd2F5cyBoYXBwZW5cbiAgICAvLyBiZWNhdXNlIHdlIGNhbid0IHByZWRpY3Qgd2hhdCB0aGUgdmFsdWVzIHdpbGwgYmUuIFdlIHdpbGwgYWxsb3cgc29tZVxuICAgIC8vIHBhcmFtZXRlcnMgdG8gb3B0IG91dCBvZiB0aGlzIGNoZWNrIGJ5IGhhdmluZyBhIG1hZ2ljIHN0cmluZyBpbiB0aGVpciBkZXNjcmlwdGlvbi5cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyh0aGlzLmZvcm1hbFBhcmFtcykuc29tZShwID0+IHAuVHlwZS5zdGFydHNXaXRoKCdBV1M6OlNTTTo6UGFyYW1ldGVyOjonKSAmJiAhcC5EZXNjcmlwdGlvbj8uaW5jbHVkZXMoU1NNUEFSQU1fTk9fSU5WQUxJREFURSkpKSB7XG4gICAgICByZXR1cm4gJ3NzbSc7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlIHdlJ3JlIGRpcnR5IGlmOlxuICAgIC8vIC0gYW55IG9mIHRoZSBleGlzdGluZyB2YWx1ZXMgYXJlIHJlbW92ZWQsIG9yIGNoYW5nZWRcbiAgICBpZiAoT2JqZWN0LmVudHJpZXMoY3VycmVudFZhbHVlcykuc29tZSgoW2tleSwgdmFsdWVdKSA9PiAhKGtleSBpbiB0aGlzLnZhbHVlcykgfHwgdmFsdWUgIT09IHRoaXMudmFsdWVzW2tleV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAtIGFueSBvZiB0aGUgdmFsdWVzIHdlJ3JlIHNldHRpbmcgYXJlIG5ld1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykuc29tZShrZXkgPT4gIShrZXkgaW4gY3VycmVudFZhbHVlcykpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUGFyYW1ldGVyQ2hhbmdlcyA9IGJvb2xlYW4gfCAnc3NtJztcbiJdfQ==