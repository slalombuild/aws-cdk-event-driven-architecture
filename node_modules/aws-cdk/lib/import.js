"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceImporter = void 0;
const cfnDiff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const fs = require("fs-extra");
const promptly = require("promptly");
const logging_1 = require("./logging");
/**
 * Resource importing utility class
 *
 * - Determines the resources added to a template (compared to the deployed version)
 * - Look up the identification information
 *   - Load them from a file, or
 *   - Ask the user, based on information supplied to us by CloudFormation's GetTemplateSummary
 * - Translate the input to a structure expected by CloudFormation, update the template to add the
 *   importable resources, then run an IMPORT changeset.
 */
class ResourceImporter {
    constructor(stack, cfn, options = {}) {
        this.stack = stack;
        this.cfn = cfn;
        this.options = options;
    }
    /**
     * Ask the user for resources to import
     */
    async askForResourceIdentifiers(available) {
        const ret = { importResources: [], resourceMap: {} };
        const resourceIdentifiers = await this.resourceIdentifiers();
        for (const resource of available) {
            const identifier = await this.askForResourceIdentifier(resourceIdentifiers, resource);
            if (!identifier) {
                continue;
            }
            ret.importResources.push(resource);
            ret.resourceMap[resource.logicalId] = identifier;
        }
        return ret;
    }
    /**
     * Load the resources to import from a file
     */
    async loadResourceIdentifiers(available, filename) {
        const contents = await fs.readJson(filename);
        const ret = { importResources: [], resourceMap: {} };
        for (const resource of available) {
            const descr = this.describeResource(resource.logicalId);
            const idProps = contents[resource.logicalId];
            if (idProps) {
                logging_1.print('%s: importing using %s', chalk.blue(descr), chalk.blue(fmtdict(idProps)));
                ret.importResources.push(resource);
                ret.resourceMap[resource.logicalId] = idProps;
                delete contents[resource.logicalId];
            }
            else {
                logging_1.print('%s: skipping', chalk.blue(descr));
            }
        }
        const unknown = Object.keys(contents);
        if (unknown.length > 0) {
            logging_1.warning(`Unrecognized resource identifiers in mapping file: ${unknown.join(', ')}`);
        }
        return ret;
    }
    /**
     * Based on the provided resource mapping, prepare CFN structures for import (template,
     * ResourcesToImport structure) and perform the import operation (CloudFormation deployment)
     *
     * @param resourceMap Mapping from CDK construct tree path to physical resource import identifiers
     * @param options Options to pass to CloudFormation deploy operation
     */
    async importResources(importMap, options) {
        const resourcesToImport = await this.makeResourcesToImport(importMap);
        const updatedTemplate = await this.currentTemplateWithAdditions(importMap.importResources);
        try {
            const result = await this.cfn.deployStack({
                ...options,
                overrideTemplate: updatedTemplate,
                resourcesToImport,
            });
            const message = result.noOp
                ? ' ✅  %s (no changes)'
                : ' ✅  %s';
            logging_1.success('\n' + message, options.stack.displayName);
        }
        catch (e) {
            logging_1.error('\n ❌  %s failed: %s', chalk.bold(options.stack.displayName), e);
            throw e;
        }
    }
    /**
     * Perform a diff between the currently running and the new template, enusre that it is valid
     * for importing and return a list of resources that are being added in the new version
     *
     * @return mapping logicalResourceId -> resourceDifference
     */
    async discoverImportableResources(allowNonAdditions = false) {
        const currentTemplate = await this.currentTemplate();
        const diff = cfnDiff.diffTemplate(currentTemplate, this.stack.template);
        // Ignore changes to CDKMetadata
        const resourceChanges = Object.entries(diff.resources.changes)
            .filter(([logicalId, _]) => logicalId !== 'CDKMetadata');
        // Split the changes into additions and non-additions. Imports only make sense
        // for newly-added resources.
        const nonAdditions = resourceChanges.filter(([_, dif]) => !dif.isAddition);
        const additions = resourceChanges.filter(([_, dif]) => dif.isAddition);
        if (nonAdditions.length) {
            const offendingResources = nonAdditions.map(([logId, _]) => this.describeResource(logId));
            if (allowNonAdditions) {
                logging_1.warning(`Ignoring updated/deleted resources (--force): ${offendingResources.join(', ')}`);
            }
            else {
                throw new Error('No resource updates or deletes are allowed on import operation. Make sure to resolve pending changes ' +
                    `to existing resources, before attempting an import. Updated/deleted resources: ${offendingResources.join(', ')} (--force to override)`);
            }
        }
        // Resources in the new template, that are not present in the current template, are a potential import candidates
        return {
            additions: additions.map(([logicalId, resourceDiff]) => ({
                logicalId,
                resourceDiff,
                resourceDefinition: addDefaultDeletionPolicy(this.stack.template?.Resources?.[logicalId] ?? {}),
            })),
            hasNonAdditions: nonAdditions.length > 0,
        };
    }
    /**
     * Get currently deployed template of the given stack (SINGLETON)
     *
     * @returns Currently deployed CloudFormation template
     */
    async currentTemplate() {
        if (!this._currentTemplate) {
            this._currentTemplate = await this.cfn.readCurrentTemplate(this.stack);
        }
        return this._currentTemplate;
    }
    /**
     * Return teh current template, with the given resources added to it
     */
    async currentTemplateWithAdditions(additions) {
        const template = await this.currentTemplate();
        if (!template.Resources) {
            template.Resources = {};
        }
        for (const add of additions) {
            template.Resources[add.logicalId] = add.resourceDefinition;
        }
        return template;
    }
    /**
     * Get a list of import identifiers for all resource types used in the given
     * template that do support the import operation (SINGLETON)
     *
     * @returns a mapping from a resource type to a list of property names that together identify the resource for import
     */
    async resourceIdentifiers() {
        const ret = {};
        const resourceIdentifierSummaries = await this.cfn.resourceIdentifierSummaries(this.stack, this.options.toolkitStackName);
        for (const summary of resourceIdentifierSummaries) {
            if ('ResourceType' in summary && summary.ResourceType && 'ResourceIdentifiers' in summary && summary.ResourceIdentifiers) {
                ret[summary.ResourceType] = summary.ResourceIdentifiers;
            }
        }
        return ret;
    }
    async askForResourceIdentifier(resourceIdentifiers, chg) {
        const resourceName = this.describeResource(chg.logicalId);
        // Skip resources that do not support importing
        const resourceType = chg.resourceDiff.newResourceType;
        if (resourceType === undefined || !(resourceType in resourceIdentifiers)) {
            logging_1.warning(`${resourceName}: unsupported resource type ${resourceType}, skipping import.`);
            return undefined;
        }
        const idProps = resourceIdentifiers[resourceType];
        const resourceProps = chg.resourceDefinition.Properties ?? {};
        const fixedIdProps = idProps.filter(p => resourceProps[p]);
        const fixedIdInput = Object.fromEntries(fixedIdProps.map(p => [p, resourceProps[p]]));
        const missingIdProps = idProps.filter(p => !resourceProps[p]);
        if (missingIdProps.length === 0) {
            // We can auto-import this, but ask the user to confirm
            const props = fmtdict(fixedIdInput);
            if (!await promptly.confirm(`${chalk.blue(resourceName)} (${resourceType}): import with ${chalk.yellow(props)} (yes/no) [default: yes]? `, { default: 'yes' })) {
                logging_1.print(chalk.grey(`Skipping import of ${resourceName}`));
                return undefined;
            }
        }
        // Ask the user to provide missing props
        const userInput = {};
        for (const missingIdProp of missingIdProps) {
            const response = (await promptly.prompt(`${chalk.blue(resourceName)} (${resourceType}): enter ${chalk.blue(missingIdProp)} to import (empty to skip):`, { default: '', trim: true }));
            if (!response) {
                logging_1.print(chalk.grey(`Skipping import of ${resourceName}`));
                return undefined;
            }
            userInput[missingIdProp] = response;
        }
        return {
            ...fixedIdInput,
            ...userInput,
        };
    }
    /**
     * Convert the internal "resource mapping" structure to CloudFormation accepted "ResourcesToImport" structure
     */
    async makeResourcesToImport(resourceMap) {
        return resourceMap.importResources.map(res => ({
            LogicalResourceId: res.logicalId,
            ResourceType: res.resourceDiff.newResourceType,
            ResourceIdentifier: resourceMap.resourceMap[res.logicalId],
        }));
    }
    /**
     * Convert CloudFormation logical resource ID to CDK construct tree path
     *
     * @param logicalId CloudFormation logical ID of the resource (the key in the template's Resources section)
     * @returns Forward-slash separated path of the resource in CDK construct tree, e.g. MyStack/MyBucket/Resource
     */
    describeResource(logicalId) {
        return this.stack.template?.Resources?.[logicalId]?.Metadata?.['aws:cdk:path'] ?? logicalId;
    }
}
exports.ResourceImporter = ResourceImporter;
function fmtdict(xs) {
    return Object.entries(xs).map(([k, v]) => `${k}=${v}`).join(', ');
}
/**
 * Add a default 'Delete' policy, which is required to make the import succeed
 */
function addDefaultDeletionPolicy(resource) {
    if (resource.DeletionPolicy) {
        return resource;
    }
    return {
        ...resource,
        DeletionPolicy: 'Delete',
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1wb3J0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiaW1wb3J0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHdEQUF3RDtBQUd4RCwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLHFDQUFxQztBQUdyQyx1Q0FBMkQ7QUEwQzNEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQWEsZ0JBQWdCO0lBRzNCLFlBQ21CLEtBQXdDLEVBQ3hDLEdBQThCLEVBQzlCLFVBQW1DLEVBQUU7UUFGckMsVUFBSyxHQUFMLEtBQUssQ0FBbUM7UUFDeEMsUUFBRyxHQUFILEdBQUcsQ0FBMkI7UUFDOUIsWUFBTyxHQUFQLE9BQU8sQ0FBOEI7SUFBSSxDQUFDO0lBRTdEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLHlCQUF5QixDQUFDLFNBQStCO1FBQ3BFLE1BQU0sR0FBRyxHQUFjLEVBQUUsZUFBZSxFQUFFLEVBQUUsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFLENBQUM7UUFDaEUsTUFBTSxtQkFBbUIsR0FBRyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1FBRTdELEtBQUssTUFBTSxRQUFRLElBQUksU0FBUyxFQUFFO1lBQ2hDLE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3RGLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2YsU0FBUzthQUNWO1lBRUQsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDbkMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsVUFBVSxDQUFDO1NBQ2xEO1FBRUQsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7SUFDSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsU0FBK0IsRUFBRSxRQUFnQjtRQUNwRixNQUFNLFFBQVEsR0FBRyxNQUFNLEVBQUUsQ0FBQyxR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OztPQUVHO0lBQ0ssS0FBSyxDQUFDLHFCQUFxQixDQUFDLFdBQXNCO1FBQ3hELE9BQU8sV0FBVyxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzdDLGlCQUFpQixFQUFFLEdBQUcsQ0FBQyxTQUFTO1lBQ2hDLFlBQVksRUFBRSxHQUFHLENBQUMsWUFBWSxDQUFDLGVBQWdCO1lBQy9DLGtCQUFrQixFQUFFLFdBQVcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQztTQUMzRCxDQUFDLENBQUMsQ0FBQztJQUNOLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLGdCQUFnQixDQUFDLFNBQWlCO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsY0FBYyxDQUFDLElBQUksU0FBUyxDQUFDO0lBQzlGLENBQUM7Q0FDRjtBQXZQRCw0Q0F1UEM7QUF3Q0QsU0FBUyxPQUFPLENBQUksRUFBcUI7SUFDdkMsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLHdCQUF3QixDQUFDLFFBQWE7SUFDN0MsSUFBSSxRQUFRLENBQUMsY0FBYyxFQUFFO1FBQUUsT0FBTyxRQUFRLENBQUM7S0FBRTtJQUVqRCxPQUFPO1FBQ0wsR0FBRyxRQUFRO1FBQ1gsY0FBYyxFQUFFLFFBQVE7S0FDekIsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZm5EaWZmIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0IHsgUmVzb3VyY2VEaWZmZXJlbmNlIH0gZnJvbSAnQGF3cy1jZGsvY2xvdWRmb3JtYXRpb24tZGlmZic7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcHJvbXB0bHkgZnJvbSAncHJvbXB0bHknO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb25EZXBsb3ltZW50cywgRGVwbG95U3RhY2tPcHRpb25zIH0gZnJvbSAnLi9hcGkvY2xvdWRmb3JtYXRpb24tZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgUmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcywgUmVzb3VyY2VzVG9JbXBvcnQgfSBmcm9tICcuL2FwaS91dGlsL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IGVycm9yLCBwcmludCwgc3VjY2Vzcywgd2FybmluZyB9IGZyb20gJy4vbG9nZ2luZyc7XG5cbi8qKlxuICogUGFyYW1ldGVycyB0aGF0IHVuaXF1ZWx5IGlkZW50aWZ5IGEgcGh5c2ljYWwgcmVzb3VyY2Ugb2YgYSBnaXZlbiB0eXBlXG4gKiBmb3IgdGhlIGltcG9ydCBvcGVyYXRpb24sIGV4YW1wbGU6XG4gKlxuICogYGBgXG4gKiB7XG4gKiAgIFwiQVdTOjpTMzo6QnVja2V0XCI6IFtcIkJ1Y2tldE5hbWVcIl0sXG4gKiAgIFwiQVdTOjpJQU06OlJvbGVcIjogW1wiUm9sZU5hbWVcIl0sXG4gKiAgIFwiQVdTOjpFQzI6OlZQQ1wiOiBbXCJWcGNJZFwiXVxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCB0eXBlIFJlc291cmNlSWRlbnRpZmllcnMgPSB7IFtyZXNvdXJjZVR5cGU6IHN0cmluZ106IHN0cmluZ1tdIH07XG5cbi8qKlxuICogTWFwcGluZyBvZiBDREsgcmVzb3VyY2VzIChMMSBjb25zdHJ1Y3RzKSB0byBwaHlzaWNhbCByZXNvdXJjZXMgdG8gYmUgaW1wb3J0ZWRcbiAqIGluIHRoZWlyIHBsYWNlLCBleGFtcGxlOlxuICpcbiAqIGBgYFxuICoge1xuICogICBcIk15U3RhY2svTXlTM0J1Y2tldC9SZXNvdXJjZVwiOiB7XG4gKiAgICAgXCJCdWNrZXROYW1lXCI6IFwibXktbWFudWFsbHktY3JlYXRlZC1zMy1idWNrZXRcIlxuICogICB9LFxuICogICBcIk15U3RhY2svTXlWcGMvUmVzb3VyY2VcIjoge1xuICogICAgIFwiVnBjSWRcIjogXCJ2cGMtMTIzNDU2Nzg5XCJcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCB0eXBlIFJlc291cmNlTWFwID0geyBbbG9naWNhbFJlc291cmNlOiBzdHJpbmddOiBSZXNvdXJjZUlkZW50aWZpZXJQcm9wZXJ0aWVzIH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VJbXBvcnRlck9wdGlvbnMge1xuICAvKipcbiAgICogTmFtZSBvZiB0b29sa2l0IHN0YWNrIGlmIG5vbi1kZWZhdWx0XG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdCB0b29sa2l0IHN0YWNrIG5hbWVcbiAgICovXG4gIHJlYWRvbmx5IHRvb2xraXRTdGFja05hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVzb3VyY2UgaW1wb3J0aW5nIHV0aWxpdHkgY2xhc3NcbiAqXG4gKiAtIERldGVybWluZXMgdGhlIHJlc291cmNlcyBhZGRlZCB0byBhIHRlbXBsYXRlIChjb21wYXJlZCB0byB0aGUgZGVwbG95ZWQgdmVyc2lvbilcbiAqIC0gTG9vayB1cCB0aGUgaWRlbnRpZmljYXRpb24gaW5mb3JtYXRpb25cbiAqICAgLSBMb2FkIHRoZW0gZnJvbSBhIGZpbGUsIG9yXG4gKiAgIC0gQXNrIHRoZSB1c2VyLCBiYXNlZCBvbiBpbmZvcm1hdGlvbiBzdXBwbGllZCB0byB1cyBieSBDbG91ZEZvcm1hdGlvbidzIEdldFRlbXBsYXRlU3VtbWFyeVxuICogLSBUcmFuc2xhdGUgdGhlIGlucHV0IHRvIGEgc3RydWN0dXJlIGV4cGVjdGVkIGJ5IENsb3VkRm9ybWF0aW9uLCB1cGRhdGUgdGhlIHRlbXBsYXRlIHRvIGFkZCB0aGVcbiAqICAgaW1wb3J0YWJsZSByZXNvdXJjZXMsIHRoZW4gcnVuIGFuIElNUE9SVCBjaGFuZ2VzZXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXNvdXJjZUltcG9ydGVyIHtcbiAgcHJpdmF0ZSBfY3VycmVudFRlbXBsYXRlOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2ZuOiBDbG91ZEZvcm1hdGlvbkRlcGxveW1lbnRzLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogUmVzb3VyY2VJbXBvcnRlck9wdGlvbnMgPSB7fSkgeyB9XG5cbiAgLyoqXG4gICAqIEFzayB0aGUgdXNlciBmb3IgcmVzb3VyY2VzIHRvIGltcG9ydFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGFza0ZvclJlc291cmNlSWRlbnRpZmllcnMoYXZhaWxhYmxlOiBJbXBvcnRhYmxlUmVzb3VyY2VbXSk6IFByb21pc2U8SW1wb3J0TWFwPiB7XG4gICAgY29uc3QgcmV0OiBJbXBvcnRNYXAgPSB7IGltcG9ydFJlc291cmNlczogW10sIHJlc291cmNlTWFwOiB7fSB9O1xuICAgIGNvbnN0IHJlc291cmNlSWRlbnRpZmllcnMgPSBhd2FpdCB0aGlzLnJlc291cmNlSWRlbnRpZmllcnMoKTtcblxuICAgIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgYXZhaWxhYmxlKSB7XG4gICAgICBjb25zdCBpZGVudGlmaWVyID0gYXdhaXQgdGhpcy5hc2tGb3JSZXNvdXJjZUlkZW50aWZpZXIocmVzb3VyY2VJZGVudGlmaWVycywgcmVzb3VyY2UpO1xuICAgICAgaWYgKCFpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXQuaW1wb3J0UmVzb3VyY2VzLnB1c2gocmVzb3VyY2UpO1xuICAgICAgcmV0LnJlc291cmNlTWFwW3Jlc291cmNlLmxvZ2ljYWxJZF0gPSBpZGVudGlmaWVyO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCB0aGUgcmVzb3VyY2VzIHRvIGltcG9ydCBmcm9tIGEgZmlsZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxvYWRSZXNvdXJjZUlkZW50aWZpZXJzKGF2YWlsYWJsZTogSW1wb3J0YWJsZVJlc291cmNlW10sIGZpbGVuYW1lOiBzdHJpbmcpOiBQcm9taXNlPEltcG9ydE1hcD4ge1xuICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgZnMucmVhZEpzb24oZmlsZW5hbWUpO1xuXG4gICAgY29uc3QgcmV0OiBJbXBvcnRNYXAgPSB7IGltcG9ydFJlc291cmNlczogW10sIHJlc291cmNlTWFwOiB7fSB9O1xuICAgIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgYXZhaWxhYmxlKSB7XG4gICAgICBjb25zdCBkZXNjciA9IHRoaXMuZGVzY3JpYmVSZXNvdXJjZShyZXNvdXJjZS5sb2dpY2FsSWQpO1xuICAgICAgY29uc3QgaWRQcm9wcyA9IGNvbnRlbnRzW3Jlc291cmNlLmxvZ2ljYWxJZF07XG4gICAgICBpZiAoaWRQcm9wcykge1xuICAgICAgICBwcmludCgnJXM6IGltcG9ydGluZyB1c2luZyAlcycsIGNoYWxrLmJsdWUoZGVzY3IpLCBjaGFsay5ibHVlKGZtdGRpY3QoaWRQcm9wcykpKTtcblxuICAgICAgICByZXQuaW1wb3J0UmVzb3VyY2VzLnB1c2gocmVzb3VyY2UpO1xuICAgICAgICByZXQucmVzb3VyY2VNYXBbcmVzb3VyY2UubG9naWNhbElkXSA9IGlkUHJvcHM7XG4gICAgICAgIGRlbGV0ZSBjb250ZW50c1tyZXNvdXJjZS5sb2dpY2FsSWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJpbnQoJyVzOiBza2lwcGluZycsIGNoYWxrLmJsdWUoZGVzY3IpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB1bmtub3duID0gT2JqZWN0LmtleXMoY29udGVudHMpO1xuICAgIGlmICh1bmtub3duLmxlbmd0aCA+IDApIHtcbiAgICAgIHdhcm5pbmcoYFVucmVjb2duaXplZCByZXNvdXJjZSBpZGVudGlmaWVycyBpbiBtYXBwaW5nIGZpbGU6ICR7dW5rbm93bi5qb2luKCcsICcpfWApO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogQmFzZWQgb24gdGhlIHByb3ZpZGVkIHJlc291cmNlIG1hcHBpbmcsIHByZXBhcmUgQ0ZOIHN0cnVjdHVyZXMgZm9yIGltcG9ydCAodGVtcGxhdGUsXG4gICAqIFJlc291cmNlc1RvSW1wb3J0IHN0cnVjdHVyZSkgYW5kIHBlcmZvcm0gdGhlIGltcG9ydCBvcGVyYXRpb24gKENsb3VkRm9ybWF0aW9uIGRlcGxveW1lbnQpXG4gICAqXG4gICAqIEBwYXJhbSByZXNvdXJjZU1hcCBNYXBwaW5nIGZyb20gQ0RLIGNvbnN0cnVjdCB0cmVlIHBhdGggdG8gcGh5c2ljYWwgcmVzb3VyY2UgaW1wb3J0IGlkZW50aWZpZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyB0byBDbG91ZEZvcm1hdGlvbiBkZXBsb3kgb3BlcmF0aW9uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW1wb3J0UmVzb3VyY2VzKGltcG9ydE1hcDogSW1wb3J0TWFwLCBvcHRpb25zOiBEZXBsb3lTdGFja09wdGlvbnMpIHtcbiAgICBjb25zdCByZXNvdXJjZXNUb0ltcG9ydDogUmVzb3VyY2VzVG9JbXBvcnQgPSBhd2FpdCB0aGlzLm1ha2VSZXNvdXJjZXNUb0ltcG9ydChpbXBvcnRNYXApO1xuICAgIGNvbnN0IHVwZGF0ZWRUZW1wbGF0ZSA9IGF3YWl0IHRoaXMuY3VycmVudFRlbXBsYXRlV2l0aEFkZGl0aW9ucyhpbXBvcnRNYXAuaW1wb3J0UmVzb3VyY2VzKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNmbi5kZXBsb3lTdGFjayh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIG92ZXJyaWRlVGVtcGxhdGU6IHVwZGF0ZWRUZW1wbGF0ZSxcbiAgICAgICAgcmVzb3VyY2VzVG9JbXBvcnQsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3VsdC5ub09wXG4gICAgICAgID8gJyDinIUgICVzIChubyBjaGFuZ2VzKSdcbiAgICAgICAgOiAnIOKchSAgJXMnO1xuXG4gICAgICBzdWNjZXNzKCdcXG4nICsgbWVzc2FnZSwgb3B0aW9ucy5zdGFjay5kaXNwbGF5TmFtZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoJ1xcbiDinYwgICVzIGZhaWxlZDogJXMnLCBjaGFsay5ib2xkKG9wdGlvbnMuc3RhY2suZGlzcGxheU5hbWUpLCBlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBkaWZmIGJldHdlZW4gdGhlIGN1cnJlbnRseSBydW5uaW5nIGFuZCB0aGUgbmV3IHRlbXBsYXRlLCBlbnVzcmUgdGhhdCBpdCBpcyB2YWxpZFxuICAgKiBmb3IgaW1wb3J0aW5nIGFuZCByZXR1cm4gYSBsaXN0IG9mIHJlc291cmNlcyB0aGF0IGFyZSBiZWluZyBhZGRlZCBpbiB0aGUgbmV3IHZlcnNpb25cbiAgICpcbiAgICogQHJldHVybiBtYXBwaW5nIGxvZ2ljYWxSZXNvdXJjZUlkIC0+IHJlc291cmNlRGlmZmVyZW5jZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpc2NvdmVySW1wb3J0YWJsZVJlc291cmNlcyhhbGxvd05vbkFkZGl0aW9ucyA9IGZhbHNlKTogUHJvbWlzZTxEaXNjb3ZlckltcG9ydGFibGVSZXNvdXJjZXNSZXN1bHQ+IHtcbiAgICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSBhd2FpdCB0aGlzLmN1cnJlbnRUZW1wbGF0ZSgpO1xuXG4gICAgY29uc3QgZGlmZiA9IGNmbkRpZmYuZGlmZlRlbXBsYXRlKGN1cnJlbnRUZW1wbGF0ZSwgdGhpcy5zdGFjay50ZW1wbGF0ZSk7XG5cbiAgICAvLyBJZ25vcmUgY2hhbmdlcyB0byBDREtNZXRhZGF0YVxuICAgIGNvbnN0IHJlc291cmNlQ2hhbmdlcyA9IE9iamVjdC5lbnRyaWVzKGRpZmYucmVzb3VyY2VzLmNoYW5nZXMpXG4gICAgICAuZmlsdGVyKChbbG9naWNhbElkLCBfXSkgPT4gbG9naWNhbElkICE9PSAnQ0RLTWV0YWRhdGEnKTtcblxuICAgIC8vIFNwbGl0IHRoZSBjaGFuZ2VzIGludG8gYWRkaXRpb25zIGFuZCBub24tYWRkaXRpb25zLiBJbXBvcnRzIG9ubHkgbWFrZSBzZW5zZVxuICAgIC8vIGZvciBuZXdseS1hZGRlZCByZXNvdXJjZXMuXG4gICAgY29uc3Qgbm9uQWRkaXRpb25zID0gcmVzb3VyY2VDaGFuZ2VzLmZpbHRlcigoW18sIGRpZl0pID0+ICFkaWYuaXNBZGRpdGlvbik7XG4gICAgY29uc3QgYWRkaXRpb25zID0gcmVzb3VyY2VDaGFuZ2VzLmZpbHRlcigoW18sIGRpZl0pID0+IGRpZi5pc0FkZGl0aW9uKTtcblxuICAgIGlmIChub25BZGRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZlbmRpbmdSZXNvdXJjZXMgPSBub25BZGRpdGlvbnMubWFwKChbbG9nSWQsIF9dKSA9PiB0aGlzLmRlc2NyaWJlUmVzb3VyY2UobG9nSWQpKTtcblxuICAgICAgaWYgKGFsbG93Tm9uQWRkaXRpb25zKSB7XG4gICAgICAgIHdhcm5pbmcoYElnbm9yaW5nIHVwZGF0ZWQvZGVsZXRlZCByZXNvdXJjZXMgKC0tZm9yY2UpOiAke29mZmVuZGluZ1Jlc291cmNlcy5qb2luKCcsICcpfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNvdXJjZSB1cGRhdGVzIG9yIGRlbGV0ZXMgYXJlIGFsbG93ZWQgb24gaW1wb3J0IG9wZXJhdGlvbi4gTWFrZSBzdXJlIHRvIHJlc29sdmUgcGVuZGluZyBjaGFuZ2VzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHRvIGV4aXN0aW5nIHJlc291cmNlcywgYmVmb3JlIGF0dGVtcHRpbmcgYW4gaW1wb3J0LiBVcGRhdGVkL2RlbGV0ZWQgcmVzb3VyY2VzOiAke29mZmVuZGluZ1Jlc291cmNlcy5qb2luKCcsICcpfSAoLS1mb3JjZSB0byBvdmVycmlkZSlgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNvdXJjZXMgaW4gdGhlIG5ldyB0ZW1wbGF0ZSwgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIGN1cnJlbnQgdGVtcGxhdGUsIGFyZSBhIHBvdGVudGlhbCBpbXBvcnQgY2FuZGlkYXRlc1xuICAgIHJldHVybiB7XG4gICAgICBhZGRpdGlvbnM6IGFkZGl0aW9ucy5tYXAoKFtsb2dpY2FsSWQsIHJlc291cmNlRGlmZl0pID0+ICh7XG4gICAgICAgIGxvZ2ljYWxJZCxcbiAgICAgICAgcmVzb3VyY2VEaWZmLFxuICAgICAgICByZXNvdXJjZURlZmluaXRpb246IGFkZERlZmF1bHREZWxldGlvblBvbGljeSh0aGlzLnN0YWNrLnRlbXBsYXRlPy5SZXNvdXJjZXM/Lltsb2dpY2FsSWRdID8/IHt9KSxcbiAgICAgIH0pKSxcbiAgICAgIGhhc05vbkFkZGl0aW9uczogbm9uQWRkaXRpb25zLmxlbmd0aCA+IDAsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudGx5IGRlcGxveWVkIHRlbXBsYXRlIG9mIHRoZSBnaXZlbiBzdGFjayAoU0lOR0xFVE9OKVxuICAgKlxuICAgKiBAcmV0dXJucyBDdXJyZW50bHkgZGVwbG95ZWQgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3VycmVudFRlbXBsYXRlKCk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50VGVtcGxhdGUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUZW1wbGF0ZSA9IGF3YWl0IHRoaXMuY2ZuLnJlYWRDdXJyZW50VGVtcGxhdGUodGhpcy5zdGFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRlaCBjdXJyZW50IHRlbXBsYXRlLCB3aXRoIHRoZSBnaXZlbiByZXNvdXJjZXMgYWRkZWQgdG8gaXRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3VycmVudFRlbXBsYXRlV2l0aEFkZGl0aW9ucyhhZGRpdGlvbnM6IEltcG9ydGFibGVSZXNvdXJjZVtdKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGF3YWl0IHRoaXMuY3VycmVudFRlbXBsYXRlKCk7XG4gICAgaWYgKCF0ZW1wbGF0ZS5SZXNvdXJjZXMpIHtcbiAgICAgIHRlbXBsYXRlLlJlc291cmNlcyA9IHt9O1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYWRkIG9mIGFkZGl0aW9ucykge1xuICAgICAgdGVtcGxhdGUuUmVzb3VyY2VzW2FkZC5sb2dpY2FsSWRdID0gYWRkLnJlc291cmNlRGVmaW5pdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBpbXBvcnQgaWRlbnRpZmllcnMgZm9yIGFsbCByZXNvdXJjZSB0eXBlcyB1c2VkIGluIHRoZSBnaXZlblxuICAgKiB0ZW1wbGF0ZSB0aGF0IGRvIHN1cHBvcnQgdGhlIGltcG9ydCBvcGVyYXRpb24gKFNJTkdMRVRPTilcbiAgICpcbiAgICogQHJldHVybnMgYSBtYXBwaW5nIGZyb20gYSByZXNvdXJjZSB0eXBlIHRvIGEgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyB0aGF0IHRvZ2V0aGVyIGlkZW50aWZ5IHRoZSByZXNvdXJjZSBmb3IgaW1wb3J0XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlc291cmNlSWRlbnRpZmllcnMoKTogUHJvbWlzZTxSZXNvdXJjZUlkZW50aWZpZXJzPiB7XG4gICAgY29uc3QgcmV0OiBSZXNvdXJjZUlkZW50aWZpZXJzID0ge307XG4gICAgY29uc3QgcmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzID0gYXdhaXQgdGhpcy5jZm4ucmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzKHRoaXMuc3RhY2ssIHRoaXMub3B0aW9ucy50b29sa2l0U3RhY2tOYW1lKTtcbiAgICBmb3IgKGNvbnN0IHN1bW1hcnkgb2YgcmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzKSB7XG4gICAgICBpZiAoJ1Jlc291cmNlVHlwZScgaW4gc3VtbWFyeSAmJiBzdW1tYXJ5LlJlc291cmNlVHlwZSAmJiAnUmVzb3VyY2VJZGVudGlmaWVycycgaW4gc3VtbWFyeSAmJiBzdW1tYXJ5LlJlc291cmNlSWRlbnRpZmllcnMpIHtcbiAgICAgICAgcmV0W3N1bW1hcnkuUmVzb3VyY2VUeXBlXSA9IHN1bW1hcnkuUmVzb3VyY2VJZGVudGlmaWVycztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgYXNrRm9yUmVzb3VyY2VJZGVudGlmaWVyKFxuICAgIHJlc291cmNlSWRlbnRpZmllcnM6IFJlc291cmNlSWRlbnRpZmllcnMsXG4gICAgY2hnOiBJbXBvcnRhYmxlUmVzb3VyY2UsXG4gICk6IFByb21pc2U8UmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IHRoaXMuZGVzY3JpYmVSZXNvdXJjZShjaGcubG9naWNhbElkKTtcblxuICAgIC8vIFNraXAgcmVzb3VyY2VzIHRoYXQgZG8gbm90IHN1cHBvcnQgaW1wb3J0aW5nXG4gICAgY29uc3QgcmVzb3VyY2VUeXBlID0gY2hnLnJlc291cmNlRGlmZi5uZXdSZXNvdXJjZVR5cGU7XG4gICAgaWYgKHJlc291cmNlVHlwZSA9PT0gdW5kZWZpbmVkIHx8ICEocmVzb3VyY2VUeXBlIGluIHJlc291cmNlSWRlbnRpZmllcnMpKSB7XG4gICAgICB3YXJuaW5nKGAke3Jlc291cmNlTmFtZX06IHVuc3VwcG9ydGVkIHJlc291cmNlIHR5cGUgJHtyZXNvdXJjZVR5cGV9LCBza2lwcGluZyBpbXBvcnQuYCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGlkUHJvcHMgPSByZXNvdXJjZUlkZW50aWZpZXJzW3Jlc291cmNlVHlwZV07XG4gICAgY29uc3QgcmVzb3VyY2VQcm9wcyA9IGNoZy5yZXNvdXJjZURlZmluaXRpb24uUHJvcGVydGllcyA/PyB7fTtcblxuICAgIGNvbnN0IGZpeGVkSWRQcm9wcyA9IGlkUHJvcHMuZmlsdGVyKHAgPT4gcmVzb3VyY2VQcm9wc1twXSk7XG4gICAgY29uc3QgZml4ZWRJZElucHV0OiBSZXNvdXJjZUlkZW50aWZpZXJQcm9wZXJ0aWVzID0gT2JqZWN0LmZyb21FbnRyaWVzKGZpeGVkSWRQcm9wcy5tYXAocCA9PiBbcCwgcmVzb3VyY2VQcm9wc1twXV0pKTtcblxuICAgIGNvbnN0IG1pc3NpbmdJZFByb3BzID0gaWRQcm9wcy5maWx0ZXIocCA9PiAhcmVzb3VyY2VQcm9wc1twXSk7XG5cbiAgICBpZiAobWlzc2luZ0lkUHJvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBXZSBjYW4gYXV0by1pbXBvcnQgdGhpcywgYnV0IGFzayB0aGUgdXNlciB0byBjb25maXJtXG4gICAgICBjb25zdCBwcm9wcyA9IGZtdGRpY3QoZml4ZWRJZElucHV0KTtcblxuICAgICAgaWYgKCFhd2FpdCBwcm9tcHRseS5jb25maXJtKFxuICAgICAgICBgJHtjaGFsay5ibHVlKHJlc291cmNlTmFtZSl9ICgke3Jlc291cmNlVHlwZX0pOiBpbXBvcnQgd2l0aCAke2NoYWxrLnllbGxvdyhwcm9wcyl9ICh5ZXMvbm8pIFtkZWZhdWx0OiB5ZXNdPyBgLFxuICAgICAgICB7IGRlZmF1bHQ6ICd5ZXMnIH0sXG4gICAgICApKSB7XG4gICAgICAgIHByaW50KGNoYWxrLmdyZXkoYFNraXBwaW5nIGltcG9ydCBvZiAke3Jlc291cmNlTmFtZX1gKSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXNrIHRoZSB1c2VyIHRvIHByb3ZpZGUgbWlzc2luZyBwcm9wc1xuICAgIGNvbnN0IHVzZXJJbnB1dDogUmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcyA9IHt9O1xuICAgIGZvciAoY29uc3QgbWlzc2luZ0lkUHJvcCBvZiBtaXNzaW5nSWRQcm9wcykge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgcHJvbXB0bHkucHJvbXB0KFxuICAgICAgICBgJHtjaGFsay5ibHVlKHJlc291cmNlTmFtZSl9ICgke3Jlc291cmNlVHlwZX0pOiBlbnRlciAke2NoYWxrLmJsdWUobWlzc2luZ0lkUHJvcCl9IHRvIGltcG9ydCAoZW1wdHkgdG8gc2tpcCk6YCxcbiAgICAgICAgeyBkZWZhdWx0OiAnJywgdHJpbTogdHJ1ZSB9LFxuICAgICAgKSk7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgIHByaW50KGNoYWxrLmdyZXkoYFNraXBwaW5nIGltcG9ydCBvZiAke3Jlc291cmNlTmFtZX1gKSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB1c2VySW5wdXRbbWlzc2luZ0lkUHJvcF0gPSByZXNwb25zZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZml4ZWRJZElucHV0LFxuICAgICAgLi4udXNlcklucHV0LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGUgaW50ZXJuYWwgXCJyZXNvdXJjZSBtYXBwaW5nXCIgc3RydWN0dXJlIHRvIENsb3VkRm9ybWF0aW9uIGFjY2VwdGVkIFwiUmVzb3VyY2VzVG9JbXBvcnRcIiBzdHJ1Y3R1cmVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbWFrZVJlc291cmNlc1RvSW1wb3J0KHJlc291cmNlTWFwOiBJbXBvcnRNYXApOiBQcm9taXNlPFJlc291cmNlc1RvSW1wb3J0PiB7XG4gICAgcmV0dXJuIHJlc291cmNlTWFwLmltcG9ydFJlc291cmNlcy5tYXAocmVzID0+ICh7XG4gICAgICBMb2dpY2FsUmVzb3VyY2VJZDogcmVzLmxvZ2ljYWxJZCxcbiAgICAgIFJlc291cmNlVHlwZTogcmVzLnJlc291cmNlRGlmZi5uZXdSZXNvdXJjZVR5cGUhLFxuICAgICAgUmVzb3VyY2VJZGVudGlmaWVyOiByZXNvdXJjZU1hcC5yZXNvdXJjZU1hcFtyZXMubG9naWNhbElkXSxcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBDbG91ZEZvcm1hdGlvbiBsb2dpY2FsIHJlc291cmNlIElEIHRvIENESyBjb25zdHJ1Y3QgdHJlZSBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSBsb2dpY2FsSWQgQ2xvdWRGb3JtYXRpb24gbG9naWNhbCBJRCBvZiB0aGUgcmVzb3VyY2UgKHRoZSBrZXkgaW4gdGhlIHRlbXBsYXRlJ3MgUmVzb3VyY2VzIHNlY3Rpb24pXG4gICAqIEByZXR1cm5zIEZvcndhcmQtc2xhc2ggc2VwYXJhdGVkIHBhdGggb2YgdGhlIHJlc291cmNlIGluIENESyBjb25zdHJ1Y3QgdHJlZSwgZS5nLiBNeVN0YWNrL015QnVja2V0L1Jlc291cmNlXG4gICAqL1xuICBwcml2YXRlIGRlc2NyaWJlUmVzb3VyY2UobG9naWNhbElkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0YWNrLnRlbXBsYXRlPy5SZXNvdXJjZXM/Lltsb2dpY2FsSWRdPy5NZXRhZGF0YT8uWydhd3M6Y2RrOnBhdGgnXSA/PyBsb2dpY2FsSWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCBhIHJlc291cmNlIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IGlzIGltcG9ydGFibGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRhYmxlUmVzb3VyY2Uge1xuICAvKipcbiAgICogVGhlIGxvZ2ljYWwgSUQgb2YgdGhlIHJlc291cmNlXG4gICAqL1xuICByZWFkb25seSBsb2dpY2FsSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlc291cmNlIGRlZmluaXRpb24gaW4gdGhlIG5ldyB0ZW1wbGF0ZVxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VEZWZpbml0aW9uOiBhbnk7XG5cbiAgLyoqXG4gICAqIFRoZSBkaWZmIGFzIHJlcG9ydGVkIGJ5IGBjbG91ZGZvcm1hdGlvbi1kaWZmYC5cbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlRGlmZjogUmVzb3VyY2VEaWZmZXJlbmNlO1xufVxuXG4vKipcbiAqIFRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gZXhlY3V0ZSBhbiBpbXBvcnQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1wb3J0TWFwIHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgbG9naWNhbCBJRHMgdG8gcGh5c2ljYWwgbmFtZXNcbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlTWFwOiBSZXNvdXJjZU1hcDtcblxuICAvKipcbiAgICogVGhlIHNlbGVjdGlvbiBvZiByZXNvdXJjZXMgd2UgYXJlIGFjdHVhbGx5IGltcG9ydGluZ1xuICAgKlxuICAgKiBGb3IgZWFjaCBvZiB0aGUgcmVzb3VyY2VzIGluIHRoaXMgbGlzdCwgdGhlcmUgaXMgYSBjb3JyZXNwb25kaW5nIGVudHJ5IGluXG4gICAqIHRoZSBgcmVzb3VyY2VNYXBgIG1hcC5cbiAgICovXG4gIHJlYWRvbmx5IGltcG9ydFJlc291cmNlczogSW1wb3J0YWJsZVJlc291cmNlW107XG59XG5cbmZ1bmN0aW9uIGZtdGRpY3Q8QT4oeHM6IFJlY29yZDxzdHJpbmcsIEE+KSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyh4cykubWFwKChbaywgdl0pID0+IGAke2t9PSR7dn1gKS5qb2luKCcsICcpO1xufVxuXG4vKipcbiAqIEFkZCBhIGRlZmF1bHQgJ0RlbGV0ZScgcG9saWN5LCB3aGljaCBpcyByZXF1aXJlZCB0byBtYWtlIHRoZSBpbXBvcnQgc3VjY2VlZFxuICovXG5mdW5jdGlvbiBhZGREZWZhdWx0RGVsZXRpb25Qb2xpY3kocmVzb3VyY2U6IGFueSk6IGFueSB7XG4gIGlmIChyZXNvdXJjZS5EZWxldGlvblBvbGljeSkgeyByZXR1cm4gcmVzb3VyY2U7IH1cblxuICByZXR1cm4ge1xuICAgIC4uLnJlc291cmNlLFxuICAgIERlbGV0aW9uUG9saWN5OiAnRGVsZXRlJyxcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEaXNjb3ZlckltcG9ydGFibGVSZXNvdXJjZXNSZXN1bHQge1xuICByZWFkb25seSBhZGRpdGlvbnM6IEltcG9ydGFibGVSZXNvdXJjZVtdO1xuICByZWFkb25seSBoYXNOb25BZGRpdGlvbnM6IGJvb2xlYW47XG59Il19