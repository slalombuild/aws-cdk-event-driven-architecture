"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const cloud_assembly_1 = require("../../lib/api/cxapp/cloud-assembly");
const context_providers_1 = require("../../lib/context-providers");
const util_1 = require("../util");
describe('AWS::CDK::Metadata', () => {
    test('is generated for relocatable stacks from old frameworks', async () => {
        await withFakeCurrentCxVersion('2.0.0', async () => {
            const cx = await testCloudExecutable({ env: `aws://${cxapi.UNKNOWN_ACCOUNT}/${cxapi.UNKNOWN_REGION}`, versionReporting: true });
            const cxasm = await cx.synthesize();
            const result = cxasm.stackById('withouterrors').firstStack;
            const metadata = result.template.Resources && result.template.Resources.CDKMetadata;
            expect(metadata).toEqual({
                Type: 'AWS::CDK::Metadata',
                Properties: {
                    // eslint-disable-next-line @typescript-eslint/no-require-imports
                    Modules: `${require('../../package.json').name}=${require('../../package.json').version}`,
                },
                Condition: 'CDKMetadataAvailable',
            });
            expect(result.template.Conditions?.CDKMetadataAvailable).toBeDefined();
        });
    });
    test('is generated for stacks in supported regions from old frameworks', async () => {
        await withFakeCurrentCxVersion('2.0.0', async () => {
            const cx = await testCloudExecutable({ env: 'aws://012345678912/us-east-1', versionReporting: true });
            const cxasm = await cx.synthesize();
            const result = cxasm.stackById('withouterrors').firstStack;
            const metadata = result.template.Resources && result.template.Resources.CDKMetadata;
            expect(metadata).toEqual({
                Type: 'AWS::CDK::Metadata',
                Properties: {
                    // eslint-disable-next-line @typescript-eslint/no-require-imports
                    Modules: `${require('../../package.json').name}=${require('../../package.json').version}`,
                },
            });
        });
    });
    test('is not generated for stacks in unsupported regions from old frameworks', async () => {
        await withFakeCurrentCxVersion('2.0.0', async () => {
            const cx = await testCloudExecutable({ env: 'aws://012345678912/bermuda-triangle-1337', versionReporting: true });
            const cxasm = await cx.synthesize();
            const result = cxasm.stackById('withouterrors').firstStack;
            const metadata = result.template.Resources && result.template.Resources.CDKMetadata;
            expect(metadata).toBeUndefined();
        });
    });
    test('is not generated for new frameworks', async () => {
        await withFakeCurrentCxVersion('8.0.0', async () => {
            const cx = await testCloudExecutable({ env: 'aws://012345678912/us-east-1', versionReporting: true });
            const cxasm = await cx.synthesize();
            const result = cxasm.stackById('withouterrors').firstStack;
            const metadata = result.template.Resources && result.template.Resources.CDKMetadata;
            expect(metadata).toBeUndefined();
        });
    });
});
test('stop executing if context providers are not making progress', async () => {
    context_providers_1.registerContextProvider(cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER, {
        async getValue(_) {
            return 'foo';
        },
    });
    const cloudExecutable = new util_1.MockCloudExecutable({
        stacks: [{
                stackName: 'thestack',
                template: { resource: 'noerrorresource' },
            }],
        // Always return the same missing keys, synthesis should still finish.
        missing: [
            { key: 'abcdef', props: { account: '1324', region: 'us-east-1' }, provider: cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER },
        ],
    });
    const cxasm = await cloudExecutable.synthesize();
    // WHEN
    await cxasm.selectStacks({ patterns: ['thestack'] }, { defaultBehavior: cloud_assembly_1.DefaultSelection.AllStacks });
    // THEN: the test finishes normally});
});
test('fails if lookups are disabled and missing context is synthesized', async () => {
    // GIVEN
    const cloudExecutable = new util_1.MockCloudExecutable({
        stacks: [{
                stackName: 'thestack',
                template: { resource: 'noerrorresource' },
            }],
        // Always return the same missing keys, synthesis should still finish.
        missing: [
            { key: 'abcdef', props: { account: '1324', region: 'us-east-1' }, provider: cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER },
        ],
    });
    cloudExecutable.configuration.settings.set(['lookups'], false);
    // WHEN
    await expect(cloudExecutable.synthesize()).rejects.toThrow(/Context lookups have been disabled/);
});
async function testCloudExecutable({ env, versionReporting = true } = {}) {
    const cloudExec = new util_1.MockCloudExecutable({
        stacks: [{
                stackName: 'withouterrors',
                env,
                template: { resource: 'noerrorresource' },
            },
            {
                stackName: 'witherrors',
                env,
                template: { resource: 'errorresource' },
                metadata: {
                    '/resource': [
                        {
                            type: cxschema.ArtifactMetadataEntryType.ERROR,
                            data: 'this is an error',
                        },
                    ],
                },
            }],
    });
    cloudExec.configuration.settings.set(['versionReporting'], versionReporting);
    return cloudExec;
}
async function withFakeCurrentCxVersion(version, block) {
    const currentVersionFn = cxschema.Manifest.version;
    cxschema.Manifest.version = () => version;
    try {
        return await block();
    }
    finally {
        cxschema.Manifest.version = currentVersionFn;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWQtZXhlY3V0YWJsZS50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY2xvdWQtZXhlY3V0YWJsZS50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMkRBQTJEO0FBQzNELHlDQUF5QztBQUN6Qyx1RUFBc0U7QUFDdEUsbUVBQXNFO0FBQ3RFLGtDQUE4QztBQUU5QyxRQUFRLENBQUMsb0JBQW9CLEVBQUUsR0FBRyxFQUFFO0lBQ2xDLElBQUksQ0FBQyx5REFBeUQsRUFBRSxLQUFLLElBQUksRUFBRTtRQUN6RSxNQUFNLHdCQUF3QixDQUFDLE9BQU8sRUFBRSxLQUFLLElBQUksRUFBRTtZQUNqRCxNQUFNLEVBQUUsR0FBRyxNQUFNLG1CQUFtQixDQUFDLEVBQUUsR0FBRyxFQUFFLFNBQVMsS0FBSyxDQUFDLGVBQWUsSUFBSSxLQUFLLENBQUMsY0FBYyxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUNoSSxNQUFNLEtBQUssR0FBRyxNQUFNLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUVwQyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxDQUFDLFVBQVUsQ0FBQztZQUMzRCxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUM7WUFDcEYsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQztnQkFDdkIsSUFBSSxFQUFFLG9CQUFvQjtnQkFDMUIsVUFBVSxFQUFFO29CQUNWLGlFQUFpRTtvQkFDakUsT0FBTyxFQUFFLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLE9BQU8sRUFBRTtpQkFDMUY7Z0JBQ0QsU0FBUyxFQUFFLHNCQUFzQjthQUNsQyxDQUFDLENBQUM7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ZSxFQUFFLEtBQXVCO0lBQ2pGLE1BQU0sZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7SUFDbkQsUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDO0lBQzFDLElBQUk7UUFDRixPQUFPLE1BQU0sS0FBSyxFQUFFLENBQUM7S0FDdEI7WUFBUztRQUNSLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxHQUFHLGdCQUFnQixDQUFDO0tBQzlDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4c2NoZW1hIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgRGVmYXVsdFNlbGVjdGlvbiB9IGZyb20gJy4uLy4uL2xpYi9hcGkvY3hhcHAvY2xvdWQtYXNzZW1ibHknO1xuaW1wb3J0IHsgcmVnaXN0ZXJDb250ZXh0UHJvdmlkZXIgfSBmcm9tICcuLi8uLi9saWIvY29udGV4dC1wcm92aWRlcnMnO1xuaW1wb3J0IHsgTW9ja0Nsb3VkRXhlY3V0YWJsZSB9IGZyb20gJy4uL3V0aWwnO1xuXG5kZXNjcmliZSgnQVdTOjpDREs6Ok1ldGFkYXRhJywgKCkgPT4ge1xuICB0ZXN0KCdpcyBnZW5lcmF0ZWQgZm9yIHJlbG9jYXRhYmxlIHN0YWNrcyBmcm9tIG9sZCBmcmFtZXdvcmtzJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHdpdGhGYWtlQ3VycmVudEN4VmVyc2lvbignMi4wLjAnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjeCA9IGF3YWl0IHRlc3RDbG91ZEV4ZWN1dGFibGUoeyBlbnY6IGBhd3M6Ly8ke2N4YXBpLlVOS05PV05fQUNDT1VOVH0vJHtjeGFwaS5VTktOT1dOX1JFR0lPTn1gLCB2ZXJzaW9uUmVwb3J0aW5nOiB0cnVlIH0pO1xuICAgICAgY29uc3QgY3hhc20gPSBhd2FpdCBjeC5zeW50aGVzaXplKCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGN4YXNtLnN0YWNrQnlJZCgnd2l0aG91dGVycm9ycycpLmZpcnN0U3RhY2s7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHJlc3VsdC50ZW1wbGF0ZS5SZXNvdXJjZXMgJiYgcmVzdWx0LnRlbXBsYXRlLlJlc291cmNlcy5DREtNZXRhZGF0YTtcbiAgICAgIGV4cGVjdChtZXRhZGF0YSkudG9FcXVhbCh7XG4gICAgICAgIFR5cGU6ICdBV1M6OkNESzo6TWV0YWRhdGEnLFxuICAgICAgICBQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgICBNb2R1bGVzOiBgJHtyZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS5uYW1lfT0ke3JlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb259YCxcbiAgICAgICAgfSxcbiAgICAgICAgQ29uZGl0aW9uOiAnQ0RLTWV0YWRhdGFBdmFpbGFibGUnLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQudGVtcGxhdGUuQ29uZGl0aW9ucz8uQ0RLTWV0YWRhdGFBdmFpbGFibGUpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHRlc3QoJ2lzIGdlbmVyYXRlZCBmb3Igc3RhY2tzIGluIHN1cHBvcnRlZCByZWdpb25zIGZyb20gb2xkIGZyYW1ld29ya3MnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgd2l0aEZha2VDdXJyZW50Q3hWZXJzaW9uKCcyLjAuMCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGN4ID0gYXdhaXQgdGVzdENsb3VkRXhlY3V0YWJsZSh7IGVudjogJ2F3czovLzAxMjM0NTY3ODkxMi91cy1lYXN0LTEnLCB2ZXJzaW9uUmVwb3J0aW5nOiB0cnVlIH0pO1xuICAgICAgY29uc3QgY3hhc20gPSBhd2FpdCBjeC5zeW50aGVzaXplKCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGN4YXNtLnN0YWNrQnlJZCgnd2l0aG91dGVycm9ycycpLmZpcnN0U3RhY2s7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHJlc3VsdC50ZW1wbGF0ZS5SZXNvdXJjZXMgJiYgcmVzdWx0LnRlbXBsYXRlLlJlc291cmNlcy5DREtNZXRhZGF0YTtcbiAgICAgIGV4cGVjdChtZXRhZGF0YSkudG9FcXVhbCh7XG4gICAgICAgIFR5cGU6ICdBV1M6OkNESzo6TWV0YWRhdGEnLFxuICAgICAgICBQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgICBNb2R1bGVzOiBgJHtyZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS5uYW1lfT0ke3JlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb259YCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICB0ZXN0KCdpcyBub3QgZ2VuZXJhdGVkIGZvciBzdGFja3MgaW4gdW5zdXBwb3J0ZWQgcmVnaW9ucyBmcm9tIG9sZCBmcmFtZXdvcmtzJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHdpdGhGYWtlQ3VycmVudEN4VmVyc2lvbignMi4wLjAnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjeCA9IGF3YWl0IHRlc3RDbG91ZEV4ZWN1dGFibGUoeyBlbnY6ICdhd3M6Ly8wMTIzNDU2Nzg5MTIvYmVybXVkYS10cmlhbmdsZS0xMzM3JywgdmVyc2lvblJlcG9ydGluZzogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IGN4YXNtID0gYXdhaXQgY3guc3ludGhlc2l6ZSgpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBjeGFzbS5zdGFja0J5SWQoJ3dpdGhvdXRlcnJvcnMnKS5maXJzdFN0YWNrO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSByZXN1bHQudGVtcGxhdGUuUmVzb3VyY2VzICYmIHJlc3VsdC50ZW1wbGF0ZS5SZXNvdXJjZXMuQ0RLTWV0YWRhdGE7XG4gICAgICBleHBlY3QobWV0YWRhdGEpLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgdGVzdCgnaXMgbm90IGdlbmVyYXRlZCBmb3IgbmV3IGZyYW1ld29ya3MnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgd2l0aEZha2VDdXJyZW50Q3hWZXJzaW9uKCc4LjAuMCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGN4ID0gYXdhaXQgdGVzdENsb3VkRXhlY3V0YWJsZSh7IGVudjogJ2F3czovLzAxMjM0NTY3ODkxMi91cy1lYXN0LTEnLCB2ZXJzaW9uUmVwb3J0aW5nOiB0cnVlIH0pO1xuICAgICAgY29uc3QgY3hhc20gPSBhd2FpdCBjeC5zeW50aGVzaXplKCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGN4YXNtLnN0YWNrQnlJZCgnd2l0aG91dGVycm9ycycpLmZpcnN0U3RhY2s7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHJlc3VsdC50ZW1wbGF0ZS5SZXNvdXJjZXMgJiYgcmVzdWx0LnRlbXBsYXRlLlJlc291cmNlcy5DREtNZXRhZGF0YTtcbiAgICAgIGV4cGVjdChtZXRhZGF0YSkudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG50ZXN0KCdzdG9wIGV4ZWN1dGluZyBpZiBjb250ZXh0IHByb3ZpZGVycyBhcmUgbm90IG1ha2luZyBwcm9ncmVzcycsIGFzeW5jICgpID0+IHtcbiAgcmVnaXN0ZXJDb250ZXh0UHJvdmlkZXIoY3hzY2hlbWEuQ29udGV4dFByb3ZpZGVyLkFWQUlMQUJJTElUWV9aT05FX1BST1ZJREVSLCB7XG4gICAgYXN5bmMgZ2V0VmFsdWUoXzogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IFByb21pc2U8YW55PiB7XG4gICAgICByZXR1cm4gJ2Zvbyc7XG4gICAgfSxcbiAgfSk7XG5cbiAgY29uc3QgY2xvdWRFeGVjdXRhYmxlID0gbmV3IE1vY2tDbG91ZEV4ZWN1dGFibGUoe1xuICAgIHN0YWNrczogW3tcbiAgICAgIHN0YWNrTmFtZTogJ3RoZXN0YWNrJyxcbiAgICAgIHRlbXBsYXRlOiB7IHJlc291cmNlOiAnbm9lcnJvcnJlc291cmNlJyB9LFxuICAgIH1dLFxuICAgIC8vIEFsd2F5cyByZXR1cm4gdGhlIHNhbWUgbWlzc2luZyBrZXlzLCBzeW50aGVzaXMgc2hvdWxkIHN0aWxsIGZpbmlzaC5cbiAgICBtaXNzaW5nOiBbXG4gICAgICB7IGtleTogJ2FiY2RlZicsIHByb3BzOiB7IGFjY291bnQ6ICcxMzI0JywgcmVnaW9uOiAndXMtZWFzdC0xJyB9LCBwcm92aWRlcjogY3hzY2hlbWEuQ29udGV4dFByb3ZpZGVyLkFWQUlMQUJJTElUWV9aT05FX1BST1ZJREVSIH0sXG4gICAgXSxcbiAgfSk7XG4gIGNvbnN0IGN4YXNtID0gYXdhaXQgY2xvdWRFeGVjdXRhYmxlLnN5bnRoZXNpemUoKTtcblxuICAvLyBXSEVOXG4gIGF3YWl0IGN4YXNtLnNlbGVjdFN0YWNrcyh7IHBhdHRlcm5zOiBbJ3RoZXN0YWNrJ10gfSwgeyBkZWZhdWx0QmVoYXZpb3I6IERlZmF1bHRTZWxlY3Rpb24uQWxsU3RhY2tzIH0pO1xuXG4gIC8vIFRIRU46IHRoZSB0ZXN0IGZpbmlzaGVzIG5vcm1hbGx5fSk7XG59KTtcblxudGVzdCgnZmFpbHMgaWYgbG9va3VwcyBhcmUgZGlzYWJsZWQgYW5kIG1pc3NpbmcgY29udGV4dCBpcyBzeW50aGVzaXplZCcsIGFzeW5jICgpID0+IHtcbiAgLy8gR0lWRU5cbiAgY29uc3QgY2xvdWRFeGVjdXRhYmxlID0gbmV3IE1vY2tDbG91ZEV4ZWN1dGFibGUoe1xuICAgIHN0YWNrczogW3tcbiAgICAgIHN0YWNrTmFtZTogJ3RoZXN0YWNrJyxcbiAgICAgIHRlbXBsYXRlOiB7IHJlc291cmNlOiAnbm9lcnJvcnJlc291cmNlJyB9LFxuICAgIH1dLFxuICAgIC8vIEFsd2F5cyByZXR1cm4gdGhlIHNhbWUgbWlzc2luZyBrZXlzLCBzeW50aGVzaXMgc2hvdWxkIHN0aWxsIGZpbmlzaC5cbiAgICBtaXNzaW5nOiBbXG4gICAgICB7IGtleTogJ2FiY2RlZicsIHByb3BzOiB7IGFjY291bnQ6ICcxMzI0JywgcmVnaW9uOiAndXMtZWFzdC0xJyB9LCBwcm92aWRlcjogY3hzY2hlbWEuQ29udGV4dFByb3ZpZGVyLkFWQUlMQUJJTElUWV9aT05FX1BST1ZJREVSIH0sXG4gICAgXSxcbiAgfSk7XG4gIGNsb3VkRXhlY3V0YWJsZS5jb25maWd1cmF0aW9uLnNldHRpbmdzLnNldChbJ2xvb2t1cHMnXSwgZmFsc2UpO1xuXG4gIC8vIFdIRU5cbiAgYXdhaXQgZXhwZWN0KGNsb3VkRXhlY3V0YWJsZS5zeW50aGVzaXplKCkpLnJlamVjdHMudG9UaHJvdygvQ29udGV4dCBsb29rdXBzIGhhdmUgYmVlbiBkaXNhYmxlZC8pO1xufSk7XG5cblxuYXN5bmMgZnVuY3Rpb24gdGVzdENsb3VkRXhlY3V0YWJsZSh7IGVudiwgdmVyc2lvblJlcG9ydGluZyA9IHRydWUgfTogeyBlbnY/OiBzdHJpbmcsIHZlcnNpb25SZXBvcnRpbmc/OiBib29sZWFuIH0gPSB7fSkge1xuICBjb25zdCBjbG91ZEV4ZWMgPSBuZXcgTW9ja0Nsb3VkRXhlY3V0YWJsZSh7XG4gICAgc3RhY2tzOiBbe1xuICAgICAgc3RhY2tOYW1lOiAnd2l0aG91dGVycm9ycycsXG4gICAgICBlbnYsXG4gICAgICB0ZW1wbGF0ZTogeyByZXNvdXJjZTogJ25vZXJyb3JyZXNvdXJjZScgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHN0YWNrTmFtZTogJ3dpdGhlcnJvcnMnLFxuICAgICAgZW52LFxuICAgICAgdGVtcGxhdGU6IHsgcmVzb3VyY2U6ICdlcnJvcnJlc291cmNlJyB9LFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgJy9yZXNvdXJjZSc6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBjeHNjaGVtYS5BcnRpZmFjdE1ldGFkYXRhRW50cnlUeXBlLkVSUk9SLFxuICAgICAgICAgICAgZGF0YTogJ3RoaXMgaXMgYW4gZXJyb3InLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIH1dLFxuICB9KTtcbiAgY2xvdWRFeGVjLmNvbmZpZ3VyYXRpb24uc2V0dGluZ3Muc2V0KFsndmVyc2lvblJlcG9ydGluZyddLCB2ZXJzaW9uUmVwb3J0aW5nKTtcblxuICByZXR1cm4gY2xvdWRFeGVjO1xufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIHdpdGhGYWtlQ3VycmVudEN4VmVyc2lvbjxBPih2ZXJzaW9uOiBzdHJpbmcsIGJsb2NrOiAoKSA9PiBQcm9taXNlPEE+KTogUHJvbWlzZTxBPiB7XG4gIGNvbnN0IGN1cnJlbnRWZXJzaW9uRm4gPSBjeHNjaGVtYS5NYW5pZmVzdC52ZXJzaW9uO1xuICBjeHNjaGVtYS5NYW5pZmVzdC52ZXJzaW9uID0gKCkgPT4gdmVyc2lvbjtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgYmxvY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjeHNjaGVtYS5NYW5pZmVzdC52ZXJzaW9uID0gY3VycmVudFZlcnNpb25GbjtcbiAgfVxufSJdfQ==